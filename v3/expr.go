package v3

import (
	"bytes"
	"fmt"
)

// expr is a unified interface for both relational and scalar expressions in a
// query. Expressions have optional inputs and filters. Specific operators also
// maintain additional expressions in the aux1 and aux2 slices. In particular,
// projectOp stores the projection expressions in aux1, groupByOp stores the
// grouping expressions in aux1 and the aggregations in aux2 and orderByOp
// stores the sorting expressions in aux2.
//
// Expressions contain a pointer to a table that defines their interface and
// logical properties. For scalar expressions, the table points the context in
// which the scalar is defined.
//
// Every unique column and every projection (that is more than just a pass
// through of a variable) is given a variable index with the query. The
// variable indexes are global to the query (see queryState). For example,
// consider the query:
//
//   SELECT x FROM a WHERE y > 0
//
// There are 2 variables in the above query: x and y. During name resolution,
// the above query becomes:
//
//   SELECT [0] FROM a WHERE [1] > 0
//   -- [0] -> x
//   -- [1] -> y
//
// This is akin to the way parser.IndexedVar works except that we're taking
// care to make the indexes unique across the entire statement. Because each of
// the relational expression nodes maintains a bitmap of the variables it
// outputs we can quickly determine if a scalar expression can be handled using
// bitmap intersection.
//
// For scalar expressions the input variables bitmap allows an easy
// determination of whether the expression is constant (the bitmap is empty)
// and, if not, which variables it uses. Predicate push down can use this
// bitmap to quickly determine whether a filter can be pushed below a
// relational operator.
//
// Relational expressions are composed of inputs, optional filters and optional
// auxiliary expressions. The output columns are derived by the operator from
// the inputs and stored in expr.table.columns.
//
//   +---------+---------+-------+--------+
//   |  out 0  |  out 1  |  ...  |  out N |
//   +---------+---------+-------+--------+
//   |             filters                |
//   +------------------------------------+
//   |        operator (aux1, aux)        |
//   +---------+---------+-------+--------+
//   |  in 0   |  in 1   |  ...  |  in N  |
//   +---------+---------+-------+--------+
//
// A query is composed of a tree of relational expressions. For example, a
// simple join might look like:
//
//   +-----------+
//   | join a, b |
//   +-----------+
//      |     |
//      |     |   +--------+
//      |     +---| scan b |
//      |         +--------+
//      |
//      |    +--------+
//      +----| scan a |
//           +--------+
//
// The output variables of each expression need to be compatible with input
// columns of its parent expression. Notice that the input variables of an
// expression constrain what output variables we need from the children. That
// constrain can be expressed by bitmap intersection. For example, consider the
// query:
//
//   SELECT a.x FROM a JOIN b USING (x)
//
// The only column from "a" that is required is "x". This is expressed in the
// code by the inputs required by the projection ("a.x") and the inputs
// required by the join condition (also "a.x").
type expr struct {
	// NB: op, projectCount and filterCount are placed next to each other in
	// order to reduce space wastage due to padding.
	op operator
	// The inputs, projections and filters are all stored in the children slice
	// to minimize overhead. The projectCount and filterCount values delineate
	// the input, projection and filter sub-slices:
	//   inputCount == len(children) - filterCount - aux1Count - aux2Count
	//   inputs:      children[:inputCount]
	//   aux1:        children[inputCount:inputCount + aux1Count]
	//   aux2:        children[inputCount+aux1Count:inputCount + aux1Count + aux2Count]
	//   filters:     children[inputCount + aux1Count + aux2Count + filterCount:]
	filterCount int16
	aux1Count   int16
	aux2Count   int16
	// The index of a data item (interface{}) for use by this expresssion. The
	// data is accessible via expr.table.state.getData(). Used by scalar
	// expressions to store additional info, such as the column name of a
	// variable or the value of a constant.
	dataIndex int32
	// The input and output bitmaps specified required inputs and generated
	// outputs. The indexes refer to queryState.columns which is constructed on a
	// per-query basis by the columns required by filters, join conditions, and
	// projections and the new columns generated by projections.
	inputVars  bitmap
	outputVars bitmap
	children   []*expr
	table      *table
}

func (e *expr) String() string {
	var buf bytes.Buffer
	e.format(&buf, 0)
	return buf.String()
}

func (e *expr) format(buf *bytes.Buffer, level int) {
	e.info().format(e, buf, level)
}

func (e *expr) formatVars(buf *bytes.Buffer) {
	if e.inputVars != 0 || e.outputVars != 0 {
		buf.WriteString(" [")
		sep := ""
		if e.inputVars != 0 {
			fmt.Fprintf(buf, "in=%s", e.inputVars)
			sep = " "
		}
		if e.outputVars != 0 {
			sep = " "
			fmt.Fprintf(buf, "%sout=%s", sep, e.outputVars)
		}
		buf.WriteString("]")
	}
}

func formatExprs(buf *bytes.Buffer, title string, exprs []*expr, level int) {
	if len(exprs) > 0 {
		indent := spaces[:2*level]
		fmt.Fprintf(buf, "%s  %s:\n", indent, title)
		for _, e := range exprs {
			e.format(buf, level+2)
		}
	}
}

func (e *expr) clone() *expr {
	t := *e
	t.children = make([]*expr, len(e.children))
	copy(t.children, e.children)
	return &t
}

func (e *expr) inputCount() int {
	return len(e.children) - int(e.filterCount+e.aux1Count+e.aux2Count)
}

func (e *expr) inputs() []*expr {
	return e.children[:e.inputCount()]
}

func (e *expr) filters() []*expr {
	filterStart := len(e.children) - int(e.filterCount)
	return e.children[filterStart:]
}

func (e *expr) addFilter(f *expr) {
	// Recursively flatten AND expressions when adding them as a filter. The
	// filters for an expression are implicitly AND'ed together (i.e. they are in
	// conjunctive normal form).
	if f.op == andOp {
		for _, input := range f.inputs() {
			e.addFilter(input)
		}
		return
	}
	e.children = append(e.children, f)
	e.filterCount++
}

func (e *expr) removeFilters() {
	filterStart := len(e.children) - int(e.filterCount)
	e.children = e.children[:filterStart]
	e.filterCount = 0
}

func (e *expr) aux1() []*expr {
	aux1Start := e.inputCount()
	return e.children[aux1Start : aux1Start+int(e.aux1Count)]
}

func (e *expr) addAux1(exprs []*expr) {
	aux2Start := len(e.children) - int(e.filterCount+e.aux2Count)
	e.children = append(e.children, exprs...)
	copy(e.children[aux2Start+len(exprs):], e.children[aux2Start:])
	copy(e.children[aux2Start:], exprs)
	e.aux1Count += int16(len(exprs))
}

func (e *expr) aux2() []*expr {
	aux2Start := e.inputCount() + int(e.aux1Count)
	return e.children[aux2Start : aux2Start+int(e.aux2Count)]
}

func (e *expr) addAux2(exprs []*expr) {
	filterStart := len(e.children) - int(e.filterCount)
	e.children = append(e.children, exprs...)
	copy(e.children[filterStart+len(exprs):], e.children[filterStart:])
	copy(e.children[filterStart:], exprs)
	e.aux2Count += int16(len(exprs))
}

func (e *expr) info() *operatorInfo {
	return &operatorTab[e.op]
}

func (e *expr) updateProperties() {
	e.info().updateProperties(e)
}
