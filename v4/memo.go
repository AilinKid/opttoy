package v4

import (
	"crypto/md5"
	"unsafe"
)

// groupID identifies a memo group. Groups have numbers greater than 0; a
// groupID of 0 indicates an empty expression or an unknown group.
type groupID uint32

// privateID identifies custom private data used by a memo expression and
// stored by the memo. Privates have numbers greater than 0; a privateID of 0
// indicates an unknown private.
type privateID uint32

type logicalPropsID uint32

type physicalPropsID uint32

const (
	wildcardPhysPropsID physicalPropsID = 1
)

// listID identifies a variable-sized list used by a memo expression and stored
// by the memo. The ID consists of an offset into the memo's lists slice, plus
// the number of elements in the list. Lists have numbers greater than 0; a
// listID of 0 indicates an unknown list.
type listID struct {
	offset uint32
	len    uint32
}

// exprFingerprint contains the fingerprint of memoExpr. Two memo expressions
// are considered equal if their fingerprints are equal. The fast-path case for
// expressions that are 16 bytes are less is to copy the memo data directly
// into the fingerprint. In the slow-path case, the md5 hash of the memo data
// is computed and stored in the fingerprint.
type exprFingerprint [md5.Size]byte

// exprOffset contains the byte offset of a memoExpr in the memo's arena.
type exprOffset uint32

// exprLoc describes the group to which an expression belongs, as well as its
// own offset into the memo's arena.
type exprLoc struct {
	group  groupID
	offset exprOffset
}

// memoExpr is a memoized representation of an expression. Specializations of
// memoExpr are generated by optgen for each operator (see expr.og.go). Each
// memoExpr belongs to a memo group, which contain logically equivalent
// expressions. Two expressions are considered logically equivalent if they
// both reduce to an identical normal form after normalizing transformations
// have been applied.
//
// The children of memoExpr are recurisvely memoized in the same way as the
// memoExpr, and are referenced by their memo group. Therefore, the memoExpr
// is the root of a forest of expressions. Each memoExpr is memoized by its
// fingerprint, which is the hash of its op type plus the group ids of its
// children.
//
// Don't change the order of the fields in memoExpr. The op field is second in
// order to make the generated fingerprint methods faster and easier to
// implement.
type memoExpr struct {
	// group identifies the memo group to which this expression belongs.
	group groupID

	// op is this expression's operator type. Each operator may have additional
	// fields. To access these fields, use the asXXX() generated methods to
	// cast the memoExpr to the more specialized expression type.
	op operator
}

type bestExpr struct {
	// op is the operator type of this expression.
	op operator

	// pass is the optimization pass in which this lowest cost expression was
	// found and entered into the bestExprs map.
	pass optimizePass

	// offset is the offset of the lowest cost expression in the memo's arena.
	offset exprOffset

	// provided are the physical properties that this expression supplies
	// either directly or indirectly (e.g. pass-through properties). These may
	// be a superset of the required properties in the bestExprs map.
	provided physicalPropsID

	// cost estimates how expensive this expression will be to execute.
	cost physicalCost
}

func (be *bestExpr) isEnforcer() bool {
	return be.offset == 0
}

// memoGroup stores a set of logically equivalent expressions. See the comments
// on memoExpr for the definition of logical equivalency.
type memoGroup struct {
	// ID (a.k.a. index) of the group within the memo.
	id groupID

	// ID of the logical properties that all memo expressions in the group share.
	logical logicalPropsID

	// Offset of the canonical, normalized representation of this expression.
	// This is used by the normalizing factory to construct normalized
	// expression trees from the bottom up.
	norm exprOffset

	// Set of logically equivalent expressions that are part of the group. Note
	// that expr 0 is not used, so that it can indicate an unknown expression.
	exprs []exprOffset

	bestExprs map[physicalPropsID]bestExpr

	// optimizeCtx is used by the optimizer to store intermediate state so that
	// redundant work is minimized. Other classes should not access this state.
	optimizeCtx struct {
		pass  optimizePass
		exprs colset
		start uint32
	}

	// exploreCtx is used by the explorer to store intermediate state so that
	// redundant work is minimized. Other classes should not access this state.
	exploreCtx struct {
		pass  optimizePass
		iter  int
		exprs colset
		start uint32
		end   uint32
	}
}

func (g *memoGroup) addExpr(offset exprOffset) {
	g.exprs = append(g.exprs, offset)
}

type memo struct {
	// In order to reduce memory usage and GC load, all memoExprs associated
	// with this memo are allocated from this arena. Expression references are
	// byte offsets into the arena (exprOffset).
	arena *arena

	// A map from expression fingerprint (memoExpr.fingerprint()) to that
	// expression's group and its offset into the arena. Note that the
	// exprOffset field may be zero for alternate fingerprints (i.e.
	// fingerprints for denormalized expressions).
	exprMap map[exprFingerprint]exprLoc

	// The slice of groups, indexed by group ID Note the group ID 0 is invalid
	// in order to allow zero initialization of an expression to indicate that
	// it did not originate from the memo.
	groups []memoGroup

	// Intern the set of unique logical properties used by groups in the memo,
	// since there are so many duplicates.
	logPropsMap map[logicalProps]logicalPropsID
	logProps    []logicalProps

	// Intern the set of unique physical properties used by expressions in the
	// memo, since there are so many duplicates.
	physPropsMap map[physicalProps]physicalPropsID
	physProps    []physicalProps

	// Some memoExprs have a variable number of children. The memoExpr stores
	// the list as a listID struct, which contains an index into this array,
	// plus the count of children. The children are stored as a slice of this
	// array. Note that listID 0 is invalid in order to indicate an unknown
	// list.
	lists []groupID

	// Optional private data attached to a memoExpr. It is stored here because
	// the arena cannot contain pointers. Note that privateID 0 is invalid in
	// order to indicate an unknown private.
	privates []interface{}

	// Intern the set of unique privates used by expressions in the memo, since
	// there are so many duplicates.
	privatesMap map[interface{}]privateID

	// The root group in the memo. This is the group for the expression added by
	// addRootGroup (i.e. the expression that we're optPass).
	root groupID
}

func newMemo() *memo {
	// NB: group 0 is reserved and intentionally nil so that the 0 group index
	// can indicate that we don't know the group for an expression. Similarly,
	// index 0 for the private data is reserved.
	m := &memo{
		exprMap:      make(map[exprFingerprint]exprLoc),
		groups:       make([]memoGroup, 1),
		logPropsMap:  make(map[logicalProps]logicalPropsID),
		physPropsMap: make(map[physicalProps]physicalPropsID),
		lists:        make([]groupID, 1),
		privates:     make([]interface{}, 1),
		privatesMap:  make(map[interface{}]privateID),
	}

	// Intern wildcard physical properties.
	physProps := physicalProps{}
	m.physProps = append(m.physProps, physProps)
	m.physPropsMap[physProps] = wildcardPhysPropsID

	return m
}

func (m *memo) getRoot() *memoGroup {
	return m.lookupGroup(m.root)
}

func (m *memo) addRoot(group groupID) {
	if m.root != 0 {
		fatalf("root has already been set")
	}

	m.root = group
}

func (m *memo) lookupGroup(group groupID) *memoGroup {
	return &m.groups[group]
}

func (m *memo) lookupGroupByFingerprint(f exprFingerprint) groupID {
	return m.exprMap[f].group
}

// lookupNormExpr returns the normal form of all logically equivalent
// expressions in the group.
func (m *memo) lookupNormExpr(group groupID) *memoExpr {
	return m.lookupExpr(m.groups[group].norm)
}

func (m *memo) lookupExpr(offset exprOffset) *memoExpr {
	return (*memoExpr)(m.arena.GetPointer(uint32(offset)))
}

func (m *memo) lookupExprOffset(mexpr *memoExpr) exprOffset {
	return exprOffset(m.arena.GetPointerOffset(unsafe.Pointer(mexpr)))
}

// addFingerprint checks whether the given fingerprint already references the
// given group. If not, it creates a new reference to that group, but without
// the offset of the corresponding expression. This is used when the optimizer
// creates expressions that are not normalized, but are not intended to be part
// of the search space. In that case, there's no reason to occupy space in the
// arena. However, it's still useful to store the fingerprint in order to avoid
// re-normalizing that expression in the future.
func (m *memo) addAltFingerprint(alt exprFingerprint, group groupID) {
	existing, ok := m.exprMap[alt]
	if ok {
		if existing.group != group {
			panic("same fingerprint cannot map to different groups")
		}
	} else {
		m.exprMap[alt] = exprLoc{group: group}
	}
}

func (m *memo) newGroup(norm *expr, offset exprOffset) groupID {
	id := groupID(len(m.groups))
	propsId := logicalPropsFactory{}.constructProps(norm)
	exprs := make([]exprOffset, 1)
	bestExprs := make(map[physicalPropsID]bestExpr)
	mgrp := memoGroup{id: id, norm: offset, logical: propsId, exprs: exprs, bestExprs: bestExprs}
	m.groups = append(m.groups, mgrp)
	return id
}

func (m *memo) storeList(list []groupID) listID {
	id := listID{offset: uint32(len(m.lists)), len: uint32(len(list))}
	m.lists = append(m.lists, list...)
	return id
}

func (m *memo) lookupList(id listID) []groupID {
	return m.lists[id.offset : id.offset+id.len]
}

func (m *memo) internPrivate(private interface{}) privateID {
	id, ok := m.privatesMap[private]
	if !ok {
		id = privateID(len(m.privates))
		m.privates = append(m.privates, private)
		m.privatesMap[private] = id
	}

	return id
}

func (m *memo) lookupPrivate(id privateID) interface{} {
	return m.privates[id]
}

func (m *memo) internLogicalProps(props *logicalProps) logicalPropsID {
	// Intern the logical properties since there are likely to be many
	// duplicates.
	id, ok := m.logPropsMap[*props]
	if !ok {
		id = logicalPropsID(len(m.logProps))
		m.logProps = append(m.logProps, *props)
		m.logPropsMap[*props] = id
	}

	return id
}

func (m *memo) lookupLogicalProps(id logicalPropsID) *logicalProps {
	return &m.logProps[id]
}

func (m *memo) internPhysicalProps(props *physicalProps) physicalPropsID {
	// Intern the physical properties since there are likely to be many
	// duplicates.
	id, ok := m.physPropsMap[*props]
	if !ok {
		id = physicalPropsID(len(m.physProps))
		m.physProps = append(m.physProps, *props)
		m.physPropsMap[*props] = id
	}

	return id
}

func (m *memo) lookupPhysicalProps(id physicalPropsID) *physicalProps {
	return &m.physProps[id]
}

// TODO: Add string representations.
