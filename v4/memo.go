package v4

import (
	"crypto/md5"
)

// groupID identifies a memo group. Groups have numbers greater than 0; a
// groupID of 0 indicates an empty expression or an unknown group.
type groupID uint32

// privateID identifies custom private data used by a memo expression and
// stored by the memo. Privates have numbers greater than 0; a privateID of 0
// indicates an unknown private.
type privateID uint32

// listID identifies a variable-sized list used by a memo expression and stored
// by the memo. The ID consists of an offset into the memo's lists slice, plus
// the number of elements in the list. Lists have numbers greater than 0; a
// listID of 0 indicates an unknown list.
type listID struct {
	offset uint32
	len    uint32
}

// exprFingerprint contains the fingerprint of memoExpr. Two memo expressions
// are considered equal if their fingerprints are equal. The fast-path case for
// expressions that are 16 bytes are less is to copy the memo data directly
// into the fingerprint. In the slow-path case, the md5 hash of the memo data
// is computed and stored in the fingerprint.
type exprFingerprint [md5.Size]byte

// exprOffset contains the byte offset of a memoExpr in the memo's arena.
type exprOffset uint32

// memoExpr is a memoized representation of an expression. Specializations of
// memoExpr are generated by optgen for each operator (see expr_gen.go). Each
// memoExpr belongs to a memo group, which contain logically equivalent
// expressions. Two expressions are considered logically equivalent if they
// both reduce to an identical normal form after normalizing transformations
// have been applied.
//
// The children of memoExpr are recurisvely memoized in the same way as the
// memoExpr, and are referenced by their memo group. Therefore, the memoExpr
// is the root of a forest of expressions. Each memoExpr is memoized by its
// fingerprint, which is the hash of its op type plus the group ids of its
// children.
//
// Don't change the order of the fields in memoExpr, since all generated
// operators start with the same fields in the same order (see expr_gen.go).
// The op field is second in order to make the generated fingerprint methods
// faster and easier to implement.
type memoExpr struct {
	// group identifies the memo group to which this expression belongs.
	group groupID

	// op is this expression's operator type. Each operator may have additional
	// fields. To access these fields, use the asXXX() generated methods to
	// cast the memoExpr to the more specialized expression type.
	op operator
}

// memoGroup stores a set of logically equivalent expressions. See the comments
// on memoExpr for the definition of logical equivalency.
type memoGroup struct {
	// ID (a.k.a. index) of the group within the memo.
	id groupID

	// Logical properties for the group that all memo expressions share.
	props *logicalProps

	// Offset of the canonical, normalized representation of this expression.
	// This is used by the normalizing factory to construct normalized
	// expression trees from the bottom up.
	norm exprOffset

	// Set of logically equivalent expressions that are part of the group.
	exprs []exprOffset
}

func (g *memoGroup) logicalProps() *logicalProps {
	return g.props
}

func (g *memoGroup) expressions() []exprOffset {
	return g.exprs
}

// addExpr adds a logically equivalent expression to the memo group.
func (g *memoGroup) addExpr(offset exprOffset) {
	g.exprs = append(g.exprs, offset)
}

type memo struct {
	// In order to reduce memory usage and GC load, all memoExprs associated
	// with this memo are allocated from this arena. Expression references are
	// byte offsets into the arena (exprOffset).
	arena *arena

	// A map from expression fingerprint (memoExpr.fingerprint()) to the offset
	// of that expression in the arena. The expression's group can then be
	// retrieved from the expression if needed.
	exprMap map[exprFingerprint]exprOffset

	// The slice of groups, indexed by group ID Note the group ID 0 is invalid
	// in order to allow zero initialization of an expression to indicate that
	// it did not originate from the memo.
	groups []memoGroup

	// Intern the set of unique logical properties used by groups in the memo,
	// since there are so many duplicates.
	logicalProps map[logicalProps]*logicalProps

	// Some memoExprs have a variable number of children. The memoExpr stores
	// the list as a listID struct, which contains an index into this array,
	// plus the count of children. The children are stored as a slice of this
	// array. Note that listID 0 is invalid in order to indicate an unknown
	// list.
	lists []groupID

	// Optional private data attached to a memoExpr. It is stored here because
	// the arena cannot contain pointers. Note that privateID 0 is invalid in
	// order to indicate an unknown private.
	privates []interface{}
}

func newMemo() *memo {
	// NB: group 0 is reserved and intentionally nil so that the 0 group index
	// can indicate that we don't know the group for an expression. Similarly,
	// index 0 for the private data is reserved.
	return &memo{
		exprMap:      make(map[exprFingerprint]exprOffset),
		groups:       make([]memoGroup, 1),
		logicalProps: make(map[logicalProps]*logicalProps),
		lists:        make([]groupID, 1),
		privates:     make([]interface{}, 1),
	}
}

func (m *memo) lookupGroup(group groupID) *memoGroup {
	return &m.groups[group]
}

func (m *memo) lookupExprByFingerprint(f exprFingerprint) exprOffset {
	return m.exprMap[f]
}

func (m *memo) lookupNormExpr(group groupID) *memoExpr {
	return m.lookupExpr(m.groups[group].norm)
}

func (m *memo) lookupExpr(offset exprOffset) *memoExpr {
	return (*memoExpr)(m.arena.GetPointer(uint32(offset)))
}

func (m *memo) newGroup(norm expr, offset exprOffset) groupID {
	id := groupID(len(m.groups))
	props := m.createLogicalProps(norm)
	m.groups = append(m.groups, memoGroup{id: id, norm: offset, props: props})
	return id
}

func (m *memo) storeList(list []groupID) listID {
	id := listID{offset: uint32(len(m.lists)), len: uint32(len(list))}
	m.lists = append(m.lists, list...)
	return id
}

func (m *memo) lookupList(id listID) []groupID {
	return m.lists[id.offset : id.offset+id.len]
}

func (m *memo) storePrivate(private interface{}) privateID {
	id := privateID(len(m.privates))
	m.privates = append(m.privates, private)
	return id
}

func (m *memo) lookupPrivate(id privateID) interface{} {
	return m.privates[id]
}

func (m *memo) createLogicalProps(e expr) *logicalProps {
	var props logicalProps

	if e.isScalar() {
		for i := 0; i < e.childCount(m); i++ {
			group := e.child(m, i)
			props.scalar.inputCols.UnionWith(m.lookupGroup(group).logicalProps().scalar.inputCols)
		}
	}

	intern, ok := m.logicalProps[props]
	if !ok {
		intern := &props
		m.logicalProps[props] = intern
	}

	return intern
}

// TODO: Add string representations.

/*
type find struct {
	memo        *memo
	degree      int
	degreeIndex int
}

func (_f *find) matchAssociateJoin(group groupID) {
	var offset exprOffset
	var r groupID
	var s groupID
	var lowerFilter groupID
	var t groupID
	var upperFilter groupID

	for _, offset = range _f.memo.lookupGroup(group).expressions() {
		innerJoinExpr := _f.memo.lookupExpr(offset).asInnerJoin()
		if innerJoinExpr != nil {

			for _, offset = range _f.memo.lookupGroup(innerJoinExpr.left).expressions() {
				innerJoinExpr2 := _f.memo.lookupExpr(offset).asInnerJoin()
				if innerJoinExpr2 != nil {
					r = innerJoinExpr2.left
					s = innerJoinExpr2.right
					lowerFilter = innerJoinExpr2.filter
					t = innerJoinExpr.right
					upperFilter = innerJoinExpr.filter

					if _f.canBeSplitColUsage(upperFilter, s) {
						// do replace
					}
				}
			}
		}
	}
}

1, 1

0 1 1

0     0
*/
