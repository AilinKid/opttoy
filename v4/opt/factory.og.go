// Code generated by optgen; DO NOT EDIT.

package opt

func (_f *Factory) ConstructVariable(
	col PrivateID,
) GroupID {
	_variableExpr := variableExpr{memoExpr: memoExpr{op: VariableOp}, col: col}
	_fingerprint := _variableExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeVariable(&_variableExpr)
}

func (_f *Factory) ConstructConst(
	value PrivateID,
) GroupID {
	_constExpr := constExpr{memoExpr: memoExpr{op: ConstOp}, value: value}
	_fingerprint := _constExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeConst(&_constExpr)
}

func (_f *Factory) ConstructPlaceholder(
	value PrivateID,
) GroupID {
	_placeholderExpr := placeholderExpr{memoExpr: memoExpr{op: PlaceholderOp}, value: value}
	_fingerprint := _placeholderExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizePlaceholder(&_placeholderExpr)
}

func (_f *Factory) ConstructList(
	items ListID,
) GroupID {
	_listExpr := listExpr{memoExpr: memoExpr{op: ListOp}, items: items}
	_fingerprint := _listExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeList(&_listExpr)
}

func (_f *Factory) ConstructOrderedList(
	items ListID,
) GroupID {
	_orderedListExpr := orderedListExpr{memoExpr: memoExpr{op: OrderedListOp}, items: items}
	_fingerprint := _orderedListExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeOrderedList(&_orderedListExpr)
}

func (_f *Factory) ConstructProjections(
	items ListID,
	cols PrivateID,
) GroupID {
	_projectionsExpr := projectionsExpr{memoExpr: memoExpr{op: ProjectionsOp}, items: items, cols: cols}
	_fingerprint := _projectionsExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeProjections(&_projectionsExpr)
}

func (_f *Factory) ConstructExists(
	input GroupID,
) GroupID {
	_existsExpr := existsExpr{memoExpr: memoExpr{op: ExistsOp}, input: input}
	_fingerprint := _existsExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeExists(&_existsExpr)
}

func (_f *Factory) ConstructAnd(
	left GroupID,
	right GroupID,
) GroupID {
	_andExpr := andExpr{memoExpr: memoExpr{op: AndOp}, left: left, right: right}
	_fingerprint := _andExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeAnd(&_andExpr)
}

func (_f *Factory) ConstructOr(
	left GroupID,
	right GroupID,
) GroupID {
	_orExpr := orExpr{memoExpr: memoExpr{op: OrOp}, left: left, right: right}
	_fingerprint := _orExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeOr(&_orExpr)
}

func (_f *Factory) ConstructNot(
	input GroupID,
) GroupID {
	_notExpr := notExpr{memoExpr: memoExpr{op: NotOp}, input: input}
	_fingerprint := _notExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeNot(&_notExpr)
}

func (_f *Factory) ConstructEq(
	left GroupID,
	right GroupID,
) GroupID {
	_eqExpr := eqExpr{memoExpr: memoExpr{op: EqOp}, left: left, right: right}
	_fingerprint := _eqExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	// [NormalizeVar]
	{
		_variable := _f.mem.lookupNormExpr(left).asVariable()
		if _variable == nil {
			_variable2 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable2 != nil {
				_group = _f.ConstructEq(right, left)
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [NormalizeVarEq]
	{
		_variable := _f.mem.lookupNormExpr(left).asVariable()
		if _variable != nil {
			_variable2 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable2 != nil {
				if _f.isLowerExpr(right, left) {
					_group = _f.ConstructEq(right, left)
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	return _f.mem.memoizeEq(&_eqExpr)
}

func (_f *Factory) ConstructLt(
	left GroupID,
	right GroupID,
) GroupID {
	_ltExpr := ltExpr{memoExpr: memoExpr{op: LtOp}, left: left, right: right}
	_fingerprint := _ltExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeLt(&_ltExpr)
}

func (_f *Factory) ConstructGt(
	left GroupID,
	right GroupID,
) GroupID {
	_gtExpr := gtExpr{memoExpr: memoExpr{op: GtOp}, left: left, right: right}
	_fingerprint := _gtExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeGt(&_gtExpr)
}

func (_f *Factory) ConstructLe(
	left GroupID,
	right GroupID,
) GroupID {
	_leExpr := leExpr{memoExpr: memoExpr{op: LeOp}, left: left, right: right}
	_fingerprint := _leExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeLe(&_leExpr)
}

func (_f *Factory) ConstructGe(
	left GroupID,
	right GroupID,
) GroupID {
	_geExpr := geExpr{memoExpr: memoExpr{op: GeOp}, left: left, right: right}
	_fingerprint := _geExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeGe(&_geExpr)
}

func (_f *Factory) ConstructNe(
	left GroupID,
	right GroupID,
) GroupID {
	_neExpr := neExpr{memoExpr: memoExpr{op: NeOp}, left: left, right: right}
	_fingerprint := _neExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeNe(&_neExpr)
}

func (_f *Factory) ConstructIn(
	left GroupID,
	right GroupID,
) GroupID {
	_inExpr := inExpr{memoExpr: memoExpr{op: InOp}, left: left, right: right}
	_fingerprint := _inExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeIn(&_inExpr)
}

func (_f *Factory) ConstructNotIn(
	left GroupID,
	right GroupID,
) GroupID {
	_notInExpr := notInExpr{memoExpr: memoExpr{op: NotInOp}, left: left, right: right}
	_fingerprint := _notInExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeNotIn(&_notInExpr)
}

func (_f *Factory) ConstructLike(
	left GroupID,
	right GroupID,
) GroupID {
	_likeExpr := likeExpr{memoExpr: memoExpr{op: LikeOp}, left: left, right: right}
	_fingerprint := _likeExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeLike(&_likeExpr)
}

func (_f *Factory) ConstructNotLike(
	left GroupID,
	right GroupID,
) GroupID {
	_notLikeExpr := notLikeExpr{memoExpr: memoExpr{op: NotLikeOp}, left: left, right: right}
	_fingerprint := _notLikeExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeNotLike(&_notLikeExpr)
}

func (_f *Factory) ConstructILike(
	left GroupID,
	right GroupID,
) GroupID {
	_iLikeExpr := iLikeExpr{memoExpr: memoExpr{op: ILikeOp}, left: left, right: right}
	_fingerprint := _iLikeExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeILike(&_iLikeExpr)
}

func (_f *Factory) ConstructNotILike(
	left GroupID,
	right GroupID,
) GroupID {
	_notILikeExpr := notILikeExpr{memoExpr: memoExpr{op: NotILikeOp}, left: left, right: right}
	_fingerprint := _notILikeExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeNotILike(&_notILikeExpr)
}

func (_f *Factory) ConstructSimilarTo(
	left GroupID,
	right GroupID,
) GroupID {
	_similarToExpr := similarToExpr{memoExpr: memoExpr{op: SimilarToOp}, left: left, right: right}
	_fingerprint := _similarToExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeSimilarTo(&_similarToExpr)
}

func (_f *Factory) ConstructNotSimilarTo(
	left GroupID,
	right GroupID,
) GroupID {
	_notSimilarToExpr := notSimilarToExpr{memoExpr: memoExpr{op: NotSimilarToOp}, left: left, right: right}
	_fingerprint := _notSimilarToExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeNotSimilarTo(&_notSimilarToExpr)
}

func (_f *Factory) ConstructRegMatch(
	left GroupID,
	right GroupID,
) GroupID {
	_regMatchExpr := regMatchExpr{memoExpr: memoExpr{op: RegMatchOp}, left: left, right: right}
	_fingerprint := _regMatchExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeRegMatch(&_regMatchExpr)
}

func (_f *Factory) ConstructNotRegMatch(
	left GroupID,
	right GroupID,
) GroupID {
	_notRegMatchExpr := notRegMatchExpr{memoExpr: memoExpr{op: NotRegMatchOp}, left: left, right: right}
	_fingerprint := _notRegMatchExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeNotRegMatch(&_notRegMatchExpr)
}

func (_f *Factory) ConstructRegIMatch(
	left GroupID,
	right GroupID,
) GroupID {
	_regIMatchExpr := regIMatchExpr{memoExpr: memoExpr{op: RegIMatchOp}, left: left, right: right}
	_fingerprint := _regIMatchExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeRegIMatch(&_regIMatchExpr)
}

func (_f *Factory) ConstructNotRegIMatch(
	left GroupID,
	right GroupID,
) GroupID {
	_notRegIMatchExpr := notRegIMatchExpr{memoExpr: memoExpr{op: NotRegIMatchOp}, left: left, right: right}
	_fingerprint := _notRegIMatchExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeNotRegIMatch(&_notRegIMatchExpr)
}

func (_f *Factory) ConstructIsDistinctFrom(
	left GroupID,
	right GroupID,
) GroupID {
	_isDistinctFromExpr := isDistinctFromExpr{memoExpr: memoExpr{op: IsDistinctFromOp}, left: left, right: right}
	_fingerprint := _isDistinctFromExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeIsDistinctFrom(&_isDistinctFromExpr)
}

func (_f *Factory) ConstructIsNotDistinctFrom(
	left GroupID,
	right GroupID,
) GroupID {
	_isNotDistinctFromExpr := isNotDistinctFromExpr{memoExpr: memoExpr{op: IsNotDistinctFromOp}, left: left, right: right}
	_fingerprint := _isNotDistinctFromExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeIsNotDistinctFrom(&_isNotDistinctFromExpr)
}

func (_f *Factory) ConstructIs(
	left GroupID,
	right GroupID,
) GroupID {
	_isExpr := isExpr{memoExpr: memoExpr{op: IsOp}, left: left, right: right}
	_fingerprint := _isExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeIs(&_isExpr)
}

func (_f *Factory) ConstructIsNot(
	left GroupID,
	right GroupID,
) GroupID {
	_isNotExpr := isNotExpr{memoExpr: memoExpr{op: IsNotOp}, left: left, right: right}
	_fingerprint := _isNotExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeIsNot(&_isNotExpr)
}

func (_f *Factory) ConstructAny(
	left GroupID,
	right GroupID,
) GroupID {
	_anyExpr := anyExpr{memoExpr: memoExpr{op: AnyOp}, left: left, right: right}
	_fingerprint := _anyExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeAny(&_anyExpr)
}

func (_f *Factory) ConstructSome(
	left GroupID,
	right GroupID,
) GroupID {
	_someExpr := someExpr{memoExpr: memoExpr{op: SomeOp}, left: left, right: right}
	_fingerprint := _someExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeSome(&_someExpr)
}

func (_f *Factory) ConstructAll(
	left GroupID,
	right GroupID,
) GroupID {
	_allExpr := allExpr{memoExpr: memoExpr{op: AllOp}, left: left, right: right}
	_fingerprint := _allExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeAll(&_allExpr)
}

func (_f *Factory) ConstructBitand(
	left GroupID,
	right GroupID,
) GroupID {
	_bitandExpr := bitandExpr{memoExpr: memoExpr{op: BitandOp}, left: left, right: right}
	_fingerprint := _bitandExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeBitand(&_bitandExpr)
}

func (_f *Factory) ConstructBitor(
	left GroupID,
	right GroupID,
) GroupID {
	_bitorExpr := bitorExpr{memoExpr: memoExpr{op: BitorOp}, left: left, right: right}
	_fingerprint := _bitorExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeBitor(&_bitorExpr)
}

func (_f *Factory) ConstructBitxor(
	left GroupID,
	right GroupID,
) GroupID {
	_bitxorExpr := bitxorExpr{memoExpr: memoExpr{op: BitxorOp}, left: left, right: right}
	_fingerprint := _bitxorExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeBitxor(&_bitxorExpr)
}

func (_f *Factory) ConstructPlus(
	left GroupID,
	right GroupID,
) GroupID {
	_plusExpr := plusExpr{memoExpr: memoExpr{op: PlusOp}, left: left, right: right}
	_fingerprint := _plusExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizePlus(&_plusExpr)
}

func (_f *Factory) ConstructMinus(
	left GroupID,
	right GroupID,
) GroupID {
	_minusExpr := minusExpr{memoExpr: memoExpr{op: MinusOp}, left: left, right: right}
	_fingerprint := _minusExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeMinus(&_minusExpr)
}

func (_f *Factory) ConstructMult(
	left GroupID,
	right GroupID,
) GroupID {
	_multExpr := multExpr{memoExpr: memoExpr{op: MultOp}, left: left, right: right}
	_fingerprint := _multExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeMult(&_multExpr)
}

func (_f *Factory) ConstructDiv(
	left GroupID,
	right GroupID,
) GroupID {
	_divExpr := divExpr{memoExpr: memoExpr{op: DivOp}, left: left, right: right}
	_fingerprint := _divExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeDiv(&_divExpr)
}

func (_f *Factory) ConstructFloorDiv(
	left GroupID,
	right GroupID,
) GroupID {
	_floorDivExpr := floorDivExpr{memoExpr: memoExpr{op: FloorDivOp}, left: left, right: right}
	_fingerprint := _floorDivExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeFloorDiv(&_floorDivExpr)
}

func (_f *Factory) ConstructMod(
	left GroupID,
	right GroupID,
) GroupID {
	_modExpr := modExpr{memoExpr: memoExpr{op: ModOp}, left: left, right: right}
	_fingerprint := _modExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeMod(&_modExpr)
}

func (_f *Factory) ConstructPow(
	left GroupID,
	right GroupID,
) GroupID {
	_powExpr := powExpr{memoExpr: memoExpr{op: PowOp}, left: left, right: right}
	_fingerprint := _powExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizePow(&_powExpr)
}

func (_f *Factory) ConstructConcat(
	left GroupID,
	right GroupID,
) GroupID {
	_concatExpr := concatExpr{memoExpr: memoExpr{op: ConcatOp}, left: left, right: right}
	_fingerprint := _concatExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeConcat(&_concatExpr)
}

func (_f *Factory) ConstructLShift(
	left GroupID,
	right GroupID,
) GroupID {
	_lShiftExpr := lShiftExpr{memoExpr: memoExpr{op: LShiftOp}, left: left, right: right}
	_fingerprint := _lShiftExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeLShift(&_lShiftExpr)
}

func (_f *Factory) ConstructRShift(
	left GroupID,
	right GroupID,
) GroupID {
	_rShiftExpr := rShiftExpr{memoExpr: memoExpr{op: RShiftOp}, left: left, right: right}
	_fingerprint := _rShiftExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeRShift(&_rShiftExpr)
}

func (_f *Factory) ConstructUnaryPlus(
	input GroupID,
) GroupID {
	_unaryPlusExpr := unaryPlusExpr{memoExpr: memoExpr{op: UnaryPlusOp}, input: input}
	_fingerprint := _unaryPlusExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeUnaryPlus(&_unaryPlusExpr)
}

func (_f *Factory) ConstructUnaryMinus(
	input GroupID,
) GroupID {
	_unaryMinusExpr := unaryMinusExpr{memoExpr: memoExpr{op: UnaryMinusOp}, input: input}
	_fingerprint := _unaryMinusExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeUnaryMinus(&_unaryMinusExpr)
}

func (_f *Factory) ConstructUnaryComplement(
	input GroupID,
) GroupID {
	_unaryComplementExpr := unaryComplementExpr{memoExpr: memoExpr{op: UnaryComplementOp}, input: input}
	_fingerprint := _unaryComplementExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeUnaryComplement(&_unaryComplementExpr)
}

func (_f *Factory) ConstructFunction(
	args ListID,
	def PrivateID,
) GroupID {
	_functionExpr := functionExpr{memoExpr: memoExpr{op: FunctionOp}, args: args, def: def}
	_fingerprint := _functionExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeFunction(&_functionExpr)
}

func (_f *Factory) ConstructTrue() GroupID {
	_trueExpr := trueExpr{memoExpr: memoExpr{op: TrueOp}}
	_fingerprint := _trueExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeTrue(&_trueExpr)
}

func (_f *Factory) ConstructFalse() GroupID {
	_falseExpr := falseExpr{memoExpr: memoExpr{op: FalseOp}}
	_fingerprint := _falseExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeFalse(&_falseExpr)
}

func (_f *Factory) ConstructScan(
	table PrivateID,
) GroupID {
	_scanExpr := scanExpr{memoExpr: memoExpr{op: ScanOp}, table: table}
	_fingerprint := _scanExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeScan(&_scanExpr)
}

func (_f *Factory) ConstructValues() GroupID {
	_valuesExpr := valuesExpr{memoExpr: memoExpr{op: ValuesOp}}
	_fingerprint := _valuesExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeValues(&_valuesExpr)
}

func (_f *Factory) ConstructSelect(
	input GroupID,
	filter GroupID,
) GroupID {
	_selectExpr := selectExpr{memoExpr: memoExpr{op: SelectOp}, input: input, filter: filter}
	_fingerprint := _selectExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeSelect(&_selectExpr)
}

func (_f *Factory) ConstructProject(
	input GroupID,
	projections GroupID,
) GroupID {
	_projectExpr := projectExpr{memoExpr: memoExpr{op: ProjectOp}, input: input, projections: projections}
	_fingerprint := _projectExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeProject(&_projectExpr)
}

func (_f *Factory) ConstructInnerJoin(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_innerJoinExpr := innerJoinExpr{memoExpr: memoExpr{op: InnerJoinOp}, left: left, right: right, filter: filter}
	_fingerprint := _innerJoinExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeInnerJoin(&_innerJoinExpr)
}

func (_f *Factory) ConstructLeftJoin(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_leftJoinExpr := leftJoinExpr{memoExpr: memoExpr{op: LeftJoinOp}, left: left, right: right, filter: filter}
	_fingerprint := _leftJoinExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeLeftJoin(&_leftJoinExpr)
}

func (_f *Factory) ConstructRightJoin(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_rightJoinExpr := rightJoinExpr{memoExpr: memoExpr{op: RightJoinOp}, left: left, right: right, filter: filter}
	_fingerprint := _rightJoinExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeRightJoin(&_rightJoinExpr)
}

func (_f *Factory) ConstructFullJoin(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_fullJoinExpr := fullJoinExpr{memoExpr: memoExpr{op: FullJoinOp}, left: left, right: right, filter: filter}
	_fingerprint := _fullJoinExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeFullJoin(&_fullJoinExpr)
}

func (_f *Factory) ConstructSemiJoin(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_semiJoinExpr := semiJoinExpr{memoExpr: memoExpr{op: SemiJoinOp}, left: left, right: right, filter: filter}
	_fingerprint := _semiJoinExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeSemiJoin(&_semiJoinExpr)
}

func (_f *Factory) ConstructAntiJoin(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_antiJoinExpr := antiJoinExpr{memoExpr: memoExpr{op: AntiJoinOp}, left: left, right: right, filter: filter}
	_fingerprint := _antiJoinExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeAntiJoin(&_antiJoinExpr)
}

func (_f *Factory) ConstructInnerJoinApply(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_innerJoinApplyExpr := innerJoinApplyExpr{memoExpr: memoExpr{op: InnerJoinApplyOp}, left: left, right: right, filter: filter}
	_fingerprint := _innerJoinApplyExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeInnerJoinApply(&_innerJoinApplyExpr)
}

func (_f *Factory) ConstructLeftJoinApply(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_leftJoinApplyExpr := leftJoinApplyExpr{memoExpr: memoExpr{op: LeftJoinApplyOp}, left: left, right: right, filter: filter}
	_fingerprint := _leftJoinApplyExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeLeftJoinApply(&_leftJoinApplyExpr)
}

func (_f *Factory) ConstructRightJoinApply(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_rightJoinApplyExpr := rightJoinApplyExpr{memoExpr: memoExpr{op: RightJoinApplyOp}, left: left, right: right, filter: filter}
	_fingerprint := _rightJoinApplyExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeRightJoinApply(&_rightJoinApplyExpr)
}

func (_f *Factory) ConstructFullJoinApply(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_fullJoinApplyExpr := fullJoinApplyExpr{memoExpr: memoExpr{op: FullJoinApplyOp}, left: left, right: right, filter: filter}
	_fingerprint := _fullJoinApplyExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeFullJoinApply(&_fullJoinApplyExpr)
}

func (_f *Factory) ConstructSemiJoinApply(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_semiJoinApplyExpr := semiJoinApplyExpr{memoExpr: memoExpr{op: SemiJoinApplyOp}, left: left, right: right, filter: filter}
	_fingerprint := _semiJoinApplyExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeSemiJoinApply(&_semiJoinApplyExpr)
}

func (_f *Factory) ConstructAntiJoinApply(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_antiJoinApplyExpr := antiJoinApplyExpr{memoExpr: memoExpr{op: AntiJoinApplyOp}, left: left, right: right, filter: filter}
	_fingerprint := _antiJoinApplyExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeAntiJoinApply(&_antiJoinApplyExpr)
}

func (_f *Factory) ConstructGroupBy(
	input GroupID,
	groupings GroupID,
	aggregations GroupID,
) GroupID {
	_groupByExpr := groupByExpr{memoExpr: memoExpr{op: GroupByOp}, input: input, groupings: groupings, aggregations: aggregations}
	_fingerprint := _groupByExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeGroupBy(&_groupByExpr)
}

func (_f *Factory) ConstructUnion(
	left GroupID,
	right GroupID,
) GroupID {
	_unionExpr := unionExpr{memoExpr: memoExpr{op: UnionOp}, left: left, right: right}
	_fingerprint := _unionExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeUnion(&_unionExpr)
}

func (_f *Factory) ConstructIntersect(
	left GroupID,
	right GroupID,
) GroupID {
	_intersectExpr := intersectExpr{memoExpr: memoExpr{op: IntersectOp}, left: left, right: right}
	_fingerprint := _intersectExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeIntersect(&_intersectExpr)
}

func (_f *Factory) ConstructExcept(
	left GroupID,
	right GroupID,
) GroupID {
	_exceptExpr := exceptExpr{memoExpr: memoExpr{op: ExceptOp}, left: left, right: right}
	_fingerprint := _exceptExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.mem.memoizeExcept(&_exceptExpr)
}
