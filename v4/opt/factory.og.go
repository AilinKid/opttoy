// Code generated by optgen; DO NOT EDIT.

package opt

func (_f *Factory) ConstructSubquery(
	input GroupID,
	projection GroupID,
) GroupID {
	_subqueryExpr := subqueryExpr{memoExpr: memoExpr{op: SubqueryOp}, input: input, projection: projection}
	_fingerprint := _subqueryExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeSubquery(&_subqueryExpr))
}

func (_f *Factory) ConstructVariable(
	col PrivateID,
) GroupID {
	_variableExpr := variableExpr{memoExpr: memoExpr{op: VariableOp}, col: col}
	_fingerprint := _variableExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeVariable(&_variableExpr))
}

func (_f *Factory) ConstructConst(
	value PrivateID,
) GroupID {
	_constExpr := constExpr{memoExpr: memoExpr{op: ConstOp}, value: value}
	_fingerprint := _constExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeConst(&_constExpr))
}

func (_f *Factory) ConstructPlaceholder(
	value PrivateID,
) GroupID {
	_placeholderExpr := placeholderExpr{memoExpr: memoExpr{op: PlaceholderOp}, value: value}
	_fingerprint := _placeholderExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizePlaceholder(&_placeholderExpr))
}

func (_f *Factory) ConstructList(
	items ListID,
) GroupID {
	_listExpr := listExpr{memoExpr: memoExpr{op: ListOp}, items: items}
	_fingerprint := _listExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeList(&_listExpr))
}

func (_f *Factory) ConstructOrderedList(
	items ListID,
) GroupID {
	_orderedListExpr := orderedListExpr{memoExpr: memoExpr{op: OrderedListOp}, items: items}
	_fingerprint := _orderedListExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeOrderedList(&_orderedListExpr))
}

func (_f *Factory) ConstructFilterList(
	conditions ListID,
) GroupID {
	_filterListExpr := filterListExpr{memoExpr: memoExpr{op: FilterListOp}, conditions: conditions}
	_fingerprint := _filterListExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeFilterList(&_filterListExpr)
	}

	// [EliminateFilterList]
	{
		var items ListID

		items = conditions
		if _f.isEmptyList(items) {
			_f.maxSteps--
			_group = _f.ConstructTrue()
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeFilterList(&_filterListExpr))
}

func (_f *Factory) ConstructProjections(
	items ListID,
	cols PrivateID,
) GroupID {
	_projectionsExpr := projectionsExpr{memoExpr: memoExpr{op: ProjectionsOp}, items: items, cols: cols}
	_fingerprint := _projectionsExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeProjections(&_projectionsExpr))
}

func (_f *Factory) ConstructExists(
	input GroupID,
) GroupID {
	_existsExpr := existsExpr{memoExpr: memoExpr{op: ExistsOp}, input: input}
	_fingerprint := _existsExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeExists(&_existsExpr))
}

func (_f *Factory) ConstructAnd(
	left GroupID,
	right GroupID,
) GroupID {
	_andExpr := andExpr{memoExpr: memoExpr{op: AndOp}, left: left, right: right}
	_fingerprint := _andExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeAnd(&_andExpr))
}

func (_f *Factory) ConstructOr(
	left GroupID,
	right GroupID,
) GroupID {
	_orExpr := orExpr{memoExpr: memoExpr{op: OrOp}, left: left, right: right}
	_fingerprint := _orExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeOr(&_orExpr))
}

func (_f *Factory) ConstructNot(
	input GroupID,
) GroupID {
	_notExpr := notExpr{memoExpr: memoExpr{op: NotOp}, input: input}
	_fingerprint := _notExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeNot(&_notExpr))
}

func (_f *Factory) ConstructEq(
	left GroupID,
	right GroupID,
) GroupID {
	_eqExpr := eqExpr{memoExpr: memoExpr{op: EqOp}, left: left, right: right}
	_fingerprint := _eqExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeEq(&_eqExpr)
	}

	// [NormalizeVar]
	{
		_variable := _f.mem.lookupNormExpr(left).asVariable()
		if _variable == nil {
			_variable2 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable2 != nil {
				_f.maxSteps--
				_group = _f.ConstructEq(right, left)
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [NormalizeVarEq]
	{
		_variable3 := _f.mem.lookupNormExpr(left).asVariable()
		if _variable3 != nil {
			_variable4 := _f.mem.lookupNormExpr(right).asVariable()
			if _variable4 != nil {
				if _f.isLowerExpr(right, left) {
					_f.maxSteps--
					_group = _f.ConstructEq(right, left)
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeEq(&_eqExpr))
}

func (_f *Factory) ConstructLt(
	left GroupID,
	right GroupID,
) GroupID {
	_ltExpr := ltExpr{memoExpr: memoExpr{op: LtOp}, left: left, right: right}
	_fingerprint := _ltExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeLt(&_ltExpr))
}

func (_f *Factory) ConstructGt(
	left GroupID,
	right GroupID,
) GroupID {
	_gtExpr := gtExpr{memoExpr: memoExpr{op: GtOp}, left: left, right: right}
	_fingerprint := _gtExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeGt(&_gtExpr))
}

func (_f *Factory) ConstructLe(
	left GroupID,
	right GroupID,
) GroupID {
	_leExpr := leExpr{memoExpr: memoExpr{op: LeOp}, left: left, right: right}
	_fingerprint := _leExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeLe(&_leExpr))
}

func (_f *Factory) ConstructGe(
	left GroupID,
	right GroupID,
) GroupID {
	_geExpr := geExpr{memoExpr: memoExpr{op: GeOp}, left: left, right: right}
	_fingerprint := _geExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeGe(&_geExpr))
}

func (_f *Factory) ConstructNe(
	left GroupID,
	right GroupID,
) GroupID {
	_neExpr := neExpr{memoExpr: memoExpr{op: NeOp}, left: left, right: right}
	_fingerprint := _neExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeNe(&_neExpr))
}

func (_f *Factory) ConstructIn(
	left GroupID,
	right GroupID,
) GroupID {
	_inExpr := inExpr{memoExpr: memoExpr{op: InOp}, left: left, right: right}
	_fingerprint := _inExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeIn(&_inExpr))
}

func (_f *Factory) ConstructNotIn(
	left GroupID,
	right GroupID,
) GroupID {
	_notInExpr := notInExpr{memoExpr: memoExpr{op: NotInOp}, left: left, right: right}
	_fingerprint := _notInExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeNotIn(&_notInExpr))
}

func (_f *Factory) ConstructLike(
	left GroupID,
	right GroupID,
) GroupID {
	_likeExpr := likeExpr{memoExpr: memoExpr{op: LikeOp}, left: left, right: right}
	_fingerprint := _likeExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeLike(&_likeExpr))
}

func (_f *Factory) ConstructNotLike(
	left GroupID,
	right GroupID,
) GroupID {
	_notLikeExpr := notLikeExpr{memoExpr: memoExpr{op: NotLikeOp}, left: left, right: right}
	_fingerprint := _notLikeExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeNotLike(&_notLikeExpr))
}

func (_f *Factory) ConstructILike(
	left GroupID,
	right GroupID,
) GroupID {
	_iLikeExpr := iLikeExpr{memoExpr: memoExpr{op: ILikeOp}, left: left, right: right}
	_fingerprint := _iLikeExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeILike(&_iLikeExpr))
}

func (_f *Factory) ConstructNotILike(
	left GroupID,
	right GroupID,
) GroupID {
	_notILikeExpr := notILikeExpr{memoExpr: memoExpr{op: NotILikeOp}, left: left, right: right}
	_fingerprint := _notILikeExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeNotILike(&_notILikeExpr))
}

func (_f *Factory) ConstructSimilarTo(
	left GroupID,
	right GroupID,
) GroupID {
	_similarToExpr := similarToExpr{memoExpr: memoExpr{op: SimilarToOp}, left: left, right: right}
	_fingerprint := _similarToExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeSimilarTo(&_similarToExpr))
}

func (_f *Factory) ConstructNotSimilarTo(
	left GroupID,
	right GroupID,
) GroupID {
	_notSimilarToExpr := notSimilarToExpr{memoExpr: memoExpr{op: NotSimilarToOp}, left: left, right: right}
	_fingerprint := _notSimilarToExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeNotSimilarTo(&_notSimilarToExpr))
}

func (_f *Factory) ConstructRegMatch(
	left GroupID,
	right GroupID,
) GroupID {
	_regMatchExpr := regMatchExpr{memoExpr: memoExpr{op: RegMatchOp}, left: left, right: right}
	_fingerprint := _regMatchExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeRegMatch(&_regMatchExpr))
}

func (_f *Factory) ConstructNotRegMatch(
	left GroupID,
	right GroupID,
) GroupID {
	_notRegMatchExpr := notRegMatchExpr{memoExpr: memoExpr{op: NotRegMatchOp}, left: left, right: right}
	_fingerprint := _notRegMatchExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeNotRegMatch(&_notRegMatchExpr))
}

func (_f *Factory) ConstructRegIMatch(
	left GroupID,
	right GroupID,
) GroupID {
	_regIMatchExpr := regIMatchExpr{memoExpr: memoExpr{op: RegIMatchOp}, left: left, right: right}
	_fingerprint := _regIMatchExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeRegIMatch(&_regIMatchExpr))
}

func (_f *Factory) ConstructNotRegIMatch(
	left GroupID,
	right GroupID,
) GroupID {
	_notRegIMatchExpr := notRegIMatchExpr{memoExpr: memoExpr{op: NotRegIMatchOp}, left: left, right: right}
	_fingerprint := _notRegIMatchExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeNotRegIMatch(&_notRegIMatchExpr))
}

func (_f *Factory) ConstructIsDistinctFrom(
	left GroupID,
	right GroupID,
) GroupID {
	_isDistinctFromExpr := isDistinctFromExpr{memoExpr: memoExpr{op: IsDistinctFromOp}, left: left, right: right}
	_fingerprint := _isDistinctFromExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeIsDistinctFrom(&_isDistinctFromExpr))
}

func (_f *Factory) ConstructIsNotDistinctFrom(
	left GroupID,
	right GroupID,
) GroupID {
	_isNotDistinctFromExpr := isNotDistinctFromExpr{memoExpr: memoExpr{op: IsNotDistinctFromOp}, left: left, right: right}
	_fingerprint := _isNotDistinctFromExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeIsNotDistinctFrom(&_isNotDistinctFromExpr))
}

func (_f *Factory) ConstructIs(
	left GroupID,
	right GroupID,
) GroupID {
	_isExpr := isExpr{memoExpr: memoExpr{op: IsOp}, left: left, right: right}
	_fingerprint := _isExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeIs(&_isExpr))
}

func (_f *Factory) ConstructIsNot(
	left GroupID,
	right GroupID,
) GroupID {
	_isNotExpr := isNotExpr{memoExpr: memoExpr{op: IsNotOp}, left: left, right: right}
	_fingerprint := _isNotExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeIsNot(&_isNotExpr))
}

func (_f *Factory) ConstructAny(
	left GroupID,
	right GroupID,
) GroupID {
	_anyExpr := anyExpr{memoExpr: memoExpr{op: AnyOp}, left: left, right: right}
	_fingerprint := _anyExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeAny(&_anyExpr))
}

func (_f *Factory) ConstructSome(
	left GroupID,
	right GroupID,
) GroupID {
	_someExpr := someExpr{memoExpr: memoExpr{op: SomeOp}, left: left, right: right}
	_fingerprint := _someExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeSome(&_someExpr))
}

func (_f *Factory) ConstructAll(
	left GroupID,
	right GroupID,
) GroupID {
	_allExpr := allExpr{memoExpr: memoExpr{op: AllOp}, left: left, right: right}
	_fingerprint := _allExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeAll(&_allExpr))
}

func (_f *Factory) ConstructBitand(
	left GroupID,
	right GroupID,
) GroupID {
	_bitandExpr := bitandExpr{memoExpr: memoExpr{op: BitandOp}, left: left, right: right}
	_fingerprint := _bitandExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeBitand(&_bitandExpr))
}

func (_f *Factory) ConstructBitor(
	left GroupID,
	right GroupID,
) GroupID {
	_bitorExpr := bitorExpr{memoExpr: memoExpr{op: BitorOp}, left: left, right: right}
	_fingerprint := _bitorExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeBitor(&_bitorExpr))
}

func (_f *Factory) ConstructBitxor(
	left GroupID,
	right GroupID,
) GroupID {
	_bitxorExpr := bitxorExpr{memoExpr: memoExpr{op: BitxorOp}, left: left, right: right}
	_fingerprint := _bitxorExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeBitxor(&_bitxorExpr))
}

func (_f *Factory) ConstructPlus(
	left GroupID,
	right GroupID,
) GroupID {
	_plusExpr := plusExpr{memoExpr: memoExpr{op: PlusOp}, left: left, right: right}
	_fingerprint := _plusExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizePlus(&_plusExpr))
}

func (_f *Factory) ConstructMinus(
	left GroupID,
	right GroupID,
) GroupID {
	_minusExpr := minusExpr{memoExpr: memoExpr{op: MinusOp}, left: left, right: right}
	_fingerprint := _minusExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeMinus(&_minusExpr))
}

func (_f *Factory) ConstructMult(
	left GroupID,
	right GroupID,
) GroupID {
	_multExpr := multExpr{memoExpr: memoExpr{op: MultOp}, left: left, right: right}
	_fingerprint := _multExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeMult(&_multExpr))
}

func (_f *Factory) ConstructDiv(
	left GroupID,
	right GroupID,
) GroupID {
	_divExpr := divExpr{memoExpr: memoExpr{op: DivOp}, left: left, right: right}
	_fingerprint := _divExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeDiv(&_divExpr))
}

func (_f *Factory) ConstructFloorDiv(
	left GroupID,
	right GroupID,
) GroupID {
	_floorDivExpr := floorDivExpr{memoExpr: memoExpr{op: FloorDivOp}, left: left, right: right}
	_fingerprint := _floorDivExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeFloorDiv(&_floorDivExpr))
}

func (_f *Factory) ConstructMod(
	left GroupID,
	right GroupID,
) GroupID {
	_modExpr := modExpr{memoExpr: memoExpr{op: ModOp}, left: left, right: right}
	_fingerprint := _modExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeMod(&_modExpr))
}

func (_f *Factory) ConstructPow(
	left GroupID,
	right GroupID,
) GroupID {
	_powExpr := powExpr{memoExpr: memoExpr{op: PowOp}, left: left, right: right}
	_fingerprint := _powExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizePow(&_powExpr))
}

func (_f *Factory) ConstructConcat(
	left GroupID,
	right GroupID,
) GroupID {
	_concatExpr := concatExpr{memoExpr: memoExpr{op: ConcatOp}, left: left, right: right}
	_fingerprint := _concatExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeConcat(&_concatExpr))
}

func (_f *Factory) ConstructLShift(
	left GroupID,
	right GroupID,
) GroupID {
	_lShiftExpr := lShiftExpr{memoExpr: memoExpr{op: LShiftOp}, left: left, right: right}
	_fingerprint := _lShiftExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeLShift(&_lShiftExpr))
}

func (_f *Factory) ConstructRShift(
	left GroupID,
	right GroupID,
) GroupID {
	_rShiftExpr := rShiftExpr{memoExpr: memoExpr{op: RShiftOp}, left: left, right: right}
	_fingerprint := _rShiftExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeRShift(&_rShiftExpr))
}

func (_f *Factory) ConstructUnaryPlus(
	input GroupID,
) GroupID {
	_unaryPlusExpr := unaryPlusExpr{memoExpr: memoExpr{op: UnaryPlusOp}, input: input}
	_fingerprint := _unaryPlusExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeUnaryPlus(&_unaryPlusExpr))
}

func (_f *Factory) ConstructUnaryMinus(
	input GroupID,
) GroupID {
	_unaryMinusExpr := unaryMinusExpr{memoExpr: memoExpr{op: UnaryMinusOp}, input: input}
	_fingerprint := _unaryMinusExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeUnaryMinus(&_unaryMinusExpr))
}

func (_f *Factory) ConstructUnaryComplement(
	input GroupID,
) GroupID {
	_unaryComplementExpr := unaryComplementExpr{memoExpr: memoExpr{op: UnaryComplementOp}, input: input}
	_fingerprint := _unaryComplementExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeUnaryComplement(&_unaryComplementExpr))
}

func (_f *Factory) ConstructFunction(
	args ListID,
	def PrivateID,
) GroupID {
	_functionExpr := functionExpr{memoExpr: memoExpr{op: FunctionOp}, args: args, def: def}
	_fingerprint := _functionExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeFunction(&_functionExpr))
}

func (_f *Factory) ConstructTrue() GroupID {
	_trueExpr := trueExpr{memoExpr: memoExpr{op: TrueOp}}
	_fingerprint := _trueExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeTrue(&_trueExpr))
}

func (_f *Factory) ConstructFalse() GroupID {
	_falseExpr := falseExpr{memoExpr: memoExpr{op: FalseOp}}
	_fingerprint := _falseExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeFalse(&_falseExpr))
}

func (_f *Factory) ConstructScan(
	table PrivateID,
) GroupID {
	_scanExpr := scanExpr{memoExpr: memoExpr{op: ScanOp}, table: table}
	_fingerprint := _scanExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeScan(&_scanExpr))
}

func (_f *Factory) ConstructValues() GroupID {
	_valuesExpr := valuesExpr{memoExpr: memoExpr{op: ValuesOp}}
	_fingerprint := _valuesExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeValues(&_valuesExpr))
}

func (_f *Factory) ConstructSelect(
	input GroupID,
	filter GroupID,
) GroupID {
	_selectExpr := selectExpr{memoExpr: memoExpr{op: SelectOp}, input: input, filter: filter}
	_fingerprint := _selectExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeSelect(&_selectExpr)
	}

	// [ExpandSelectExists]
	{
		var list ListID
		var exists GroupID
		var subquery GroupID

		_filterList := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList != nil {
			list = _filterList.conditions
			for _, _item := range _f.mem.lookupList(_filterList.conditions) {
				exists = _item
				_exists := _f.mem.lookupNormExpr(_item).asExists()
				if _exists != nil {
					subquery = _exists.input
					_f.maxSteps--
					_group = _f.ConstructSemiJoinApply(input, subquery, _f.ConstructFilterList(_f.removeListItem(list, exists)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [ExpandSelectNotExists]
	{
		var list ListID
		var exists GroupID
		var subquery GroupID

		_filterList2 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList2 != nil {
			list = _filterList2.conditions
			for _, _item := range _f.mem.lookupList(_filterList2.conditions) {
				exists = _item
				_not := _f.mem.lookupNormExpr(_item).asNot()
				if _not != nil {
					_exists2 := _f.mem.lookupNormExpr(_not.input).asExists()
					if _exists2 != nil {
						subquery = _exists2.input
						_f.maxSteps--
						_group = _f.ConstructAntiJoinApply(input, subquery, _f.ConstructFilterList(_f.removeListItem(list, exists)))
						_f.mem.addAltFingerprint(_fingerprint, _group)
						return _group
					}
				}
			}
		}
	}

	// [HoistSelectFilterSubquery]
	{
		var list ListID
		var subquery GroupID
		var subqueryInput GroupID
		var projection GroupID

		_filterList3 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList3 != nil {
			list = _filterList3.conditions
			for _, _item := range _f.mem.lookupList(_filterList3.conditions) {
				subquery = _item
				_subquery := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery != nil {
					subqueryInput = _subquery.input
					projection = _subquery.projection
					_f.maxSteps--
					_group = _f.ConstructInnerJoinApply(input, subqueryInput, _f.ConstructFilterList(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [EliminateSelect]
	{
		_true := _f.mem.lookupNormExpr(filter).asTrue()
		if _true != nil {
			_f.maxSteps--
			_group = input
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	// [EnsureSelectFilterList]
	{
		_filterList4 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList4 == nil {
			if _f.useFilterList(filter) {
				_f.maxSteps--
				_group = _f.ConstructSelect(input, _f.flattenFilterCondition(filter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeSelect(&_selectExpr))
}

func (_f *Factory) ConstructProject(
	input GroupID,
	projections GroupID,
) GroupID {
	_projectExpr := projectExpr{memoExpr: memoExpr{op: ProjectOp}, input: input, projections: projections}
	_fingerprint := _projectExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeProject(&_projectExpr)
	}

	// [EliminateProject]
	{
		if _f.projectsSameCols(projections, input) {
			_f.maxSteps--
			_group = input
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeProject(&_projectExpr))
}

func (_f *Factory) ConstructInnerJoin(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_innerJoinExpr := innerJoinExpr{memoExpr: memoExpr{op: InnerJoinOp}, left: left, right: right, filter: filter}
	_fingerprint := _innerJoinExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeInnerJoin(&_innerJoinExpr)
	}

	// [HoistJoinFilterSubquery]
	{
		var list ListID
		var subquery GroupID
		var subqueryInput GroupID
		var projection GroupID

		_filterList5 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList5 != nil {
			list = _filterList5.conditions
			for _, _item := range _f.mem.lookupList(_filterList5.conditions) {
				subquery = _item
				_subquery2 := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery2 != nil {
					subqueryInput = _subquery2.input
					projection = _subquery2.projection
					_f.maxSteps--
					_group = _f.ConstructInnerJoinApply(_f.ConstructInnerJoin(left, right, _f.ConstructTrue()), subqueryInput, _f.ConstructFilterList(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [EnsureJoinFilterList]
	{
		_filterList6 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList6 == nil {
			if _f.useFilterList(filter) {
				_f.maxSteps--
				_group = _f.ConstructInnerJoin(left, right, _f.flattenFilterCondition(filter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [MergeJoinSelect]
	{
		var input GroupID
		var selectFilter GroupID

		_select := _f.mem.lookupNormExpr(right).asSelect()
		if _select != nil {
			input = _select.input
			selectFilter = _select.filter
			if _f.hasUnboundCols(right) {
				_f.maxSteps--
				_group = _f.ConstructInnerJoin(left, input, _f.concatFilterConditions(filter, selectFilter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeInnerJoin(&_innerJoinExpr))
}

func (_f *Factory) ConstructLeftJoin(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_leftJoinExpr := leftJoinExpr{memoExpr: memoExpr{op: LeftJoinOp}, left: left, right: right, filter: filter}
	_fingerprint := _leftJoinExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeLeftJoin(&_leftJoinExpr)
	}

	// [HoistJoinFilterSubquery]
	{
		var list ListID
		var subquery GroupID
		var subqueryInput GroupID
		var projection GroupID

		_filterList7 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList7 != nil {
			list = _filterList7.conditions
			for _, _item := range _f.mem.lookupList(_filterList7.conditions) {
				subquery = _item
				_subquery3 := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery3 != nil {
					subqueryInput = _subquery3.input
					projection = _subquery3.projection
					_f.maxSteps--
					_group = _f.ConstructInnerJoinApply(_f.ConstructLeftJoin(left, right, _f.ConstructTrue()), subqueryInput, _f.ConstructFilterList(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [EnsureJoinFilterList]
	{
		_filterList8 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList8 == nil {
			if _f.useFilterList(filter) {
				_f.maxSteps--
				_group = _f.ConstructLeftJoin(left, right, _f.flattenFilterCondition(filter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [MergeJoinSelect]
	{
		var input GroupID
		var selectFilter GroupID

		_select2 := _f.mem.lookupNormExpr(right).asSelect()
		if _select2 != nil {
			input = _select2.input
			selectFilter = _select2.filter
			if _f.hasUnboundCols(right) {
				_f.maxSteps--
				_group = _f.ConstructLeftJoin(left, input, _f.concatFilterConditions(filter, selectFilter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeLeftJoin(&_leftJoinExpr))
}

func (_f *Factory) ConstructRightJoin(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_rightJoinExpr := rightJoinExpr{memoExpr: memoExpr{op: RightJoinOp}, left: left, right: right, filter: filter}
	_fingerprint := _rightJoinExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeRightJoin(&_rightJoinExpr)
	}

	// [HoistJoinFilterSubquery]
	{
		var list ListID
		var subquery GroupID
		var subqueryInput GroupID
		var projection GroupID

		_filterList9 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList9 != nil {
			list = _filterList9.conditions
			for _, _item := range _f.mem.lookupList(_filterList9.conditions) {
				subquery = _item
				_subquery4 := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery4 != nil {
					subqueryInput = _subquery4.input
					projection = _subquery4.projection
					_f.maxSteps--
					_group = _f.ConstructInnerJoinApply(_f.ConstructRightJoin(left, right, _f.ConstructTrue()), subqueryInput, _f.ConstructFilterList(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [EnsureJoinFilterList]
	{
		_filterList10 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList10 == nil {
			if _f.useFilterList(filter) {
				_f.maxSteps--
				_group = _f.ConstructRightJoin(left, right, _f.flattenFilterCondition(filter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [MergeJoinSelect]
	{
		var input GroupID
		var selectFilter GroupID

		_select3 := _f.mem.lookupNormExpr(right).asSelect()
		if _select3 != nil {
			input = _select3.input
			selectFilter = _select3.filter
			if _f.hasUnboundCols(right) {
				_f.maxSteps--
				_group = _f.ConstructRightJoin(left, input, _f.concatFilterConditions(filter, selectFilter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeRightJoin(&_rightJoinExpr))
}

func (_f *Factory) ConstructFullJoin(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_fullJoinExpr := fullJoinExpr{memoExpr: memoExpr{op: FullJoinOp}, left: left, right: right, filter: filter}
	_fingerprint := _fullJoinExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeFullJoin(&_fullJoinExpr)
	}

	// [HoistJoinFilterSubquery]
	{
		var list ListID
		var subquery GroupID
		var subqueryInput GroupID
		var projection GroupID

		_filterList11 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList11 != nil {
			list = _filterList11.conditions
			for _, _item := range _f.mem.lookupList(_filterList11.conditions) {
				subquery = _item
				_subquery5 := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery5 != nil {
					subqueryInput = _subquery5.input
					projection = _subquery5.projection
					_f.maxSteps--
					_group = _f.ConstructInnerJoinApply(_f.ConstructFullJoin(left, right, _f.ConstructTrue()), subqueryInput, _f.ConstructFilterList(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [EnsureJoinFilterList]
	{
		_filterList12 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList12 == nil {
			if _f.useFilterList(filter) {
				_f.maxSteps--
				_group = _f.ConstructFullJoin(left, right, _f.flattenFilterCondition(filter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [MergeJoinSelect]
	{
		var input GroupID
		var selectFilter GroupID

		_select4 := _f.mem.lookupNormExpr(right).asSelect()
		if _select4 != nil {
			input = _select4.input
			selectFilter = _select4.filter
			if _f.hasUnboundCols(right) {
				_f.maxSteps--
				_group = _f.ConstructFullJoin(left, input, _f.concatFilterConditions(filter, selectFilter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeFullJoin(&_fullJoinExpr))
}

func (_f *Factory) ConstructSemiJoin(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_semiJoinExpr := semiJoinExpr{memoExpr: memoExpr{op: SemiJoinOp}, left: left, right: right, filter: filter}
	_fingerprint := _semiJoinExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeSemiJoin(&_semiJoinExpr)
	}

	// [HoistJoinFilterSubquery]
	{
		var list ListID
		var subquery GroupID
		var subqueryInput GroupID
		var projection GroupID

		_filterList13 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList13 != nil {
			list = _filterList13.conditions
			for _, _item := range _f.mem.lookupList(_filterList13.conditions) {
				subquery = _item
				_subquery6 := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery6 != nil {
					subqueryInput = _subquery6.input
					projection = _subquery6.projection
					_f.maxSteps--
					_group = _f.ConstructInnerJoinApply(_f.ConstructSemiJoin(left, right, _f.ConstructTrue()), subqueryInput, _f.ConstructFilterList(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [EnsureJoinFilterList]
	{
		_filterList14 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList14 == nil {
			if _f.useFilterList(filter) {
				_f.maxSteps--
				_group = _f.ConstructSemiJoin(left, right, _f.flattenFilterCondition(filter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [MergeJoinSelect]
	{
		var input GroupID
		var selectFilter GroupID

		_select5 := _f.mem.lookupNormExpr(right).asSelect()
		if _select5 != nil {
			input = _select5.input
			selectFilter = _select5.filter
			if _f.hasUnboundCols(right) {
				_f.maxSteps--
				_group = _f.ConstructSemiJoin(left, input, _f.concatFilterConditions(filter, selectFilter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeSemiJoin(&_semiJoinExpr))
}

func (_f *Factory) ConstructAntiJoin(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_antiJoinExpr := antiJoinExpr{memoExpr: memoExpr{op: AntiJoinOp}, left: left, right: right, filter: filter}
	_fingerprint := _antiJoinExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeAntiJoin(&_antiJoinExpr)
	}

	// [HoistJoinFilterSubquery]
	{
		var list ListID
		var subquery GroupID
		var subqueryInput GroupID
		var projection GroupID

		_filterList15 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList15 != nil {
			list = _filterList15.conditions
			for _, _item := range _f.mem.lookupList(_filterList15.conditions) {
				subquery = _item
				_subquery7 := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery7 != nil {
					subqueryInput = _subquery7.input
					projection = _subquery7.projection
					_f.maxSteps--
					_group = _f.ConstructInnerJoinApply(_f.ConstructAntiJoin(left, right, _f.ConstructTrue()), subqueryInput, _f.ConstructFilterList(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [EnsureJoinFilterList]
	{
		_filterList16 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList16 == nil {
			if _f.useFilterList(filter) {
				_f.maxSteps--
				_group = _f.ConstructAntiJoin(left, right, _f.flattenFilterCondition(filter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [MergeJoinSelect]
	{
		var input GroupID
		var selectFilter GroupID

		_select6 := _f.mem.lookupNormExpr(right).asSelect()
		if _select6 != nil {
			input = _select6.input
			selectFilter = _select6.filter
			if _f.hasUnboundCols(right) {
				_f.maxSteps--
				_group = _f.ConstructAntiJoin(left, input, _f.concatFilterConditions(filter, selectFilter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeAntiJoin(&_antiJoinExpr))
}

func (_f *Factory) ConstructInnerJoinApply(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_innerJoinApplyExpr := innerJoinApplyExpr{memoExpr: memoExpr{op: InnerJoinApplyOp}, left: left, right: right, filter: filter}
	_fingerprint := _innerJoinApplyExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeInnerJoinApply(&_innerJoinApplyExpr)
	}

	// [HoistJoinProject]
	{
		var input GroupID
		var projections GroupID

		_project := _f.mem.lookupNormExpr(right).asProject()
		if _project != nil {
			input = _project.input
			projections = _project.projections
			if _f.isCorrelated(right, left) {
				_f.maxSteps--
				_group = _f.ConstructSelect(_f.ConstructProject(_f.ConstructInnerJoinApply(left, input, _f.ConstructTrue()), _f.appendColumnProjections(projections, left)), filter)
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [HoistJoinGroupBy]
	{
		var input GroupID
		var items ListID
		var aggregations GroupID

		_groupBy := _f.mem.lookupNormExpr(right).asGroupBy()
		if _groupBy != nil {
			input = _groupBy.input
			_projections := _f.mem.lookupNormExpr(_groupBy.groupings).asProjections()
			if _projections != nil {
				items = _projections.items
				if _f.isEmptyList(items) {
					aggregations = _groupBy.aggregations
					if _f.isCorrelated(right, left) {
						_f.maxSteps--
						_group = _f.ConstructSelect(_f.ConstructGroupBy(_f.ConstructLeftJoinApply(left, input, _f.ConstructTrue()), _f.columnProjections(left), aggregations), filter)
						_f.mem.addAltFingerprint(_fingerprint, _group)
						return _group
					}
				}
			}
		}
	}

	// [DecorrelateJoin]
	{
		if !_f.isCorrelated(right, left) {
			_f.maxSteps--
			_group = _f.nonJoinApply(InnerJoinApplyOp, left, right, filter)
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	// [HoistJoinFilterSubquery]
	{
		var list ListID
		var subquery GroupID
		var subqueryInput GroupID
		var projection GroupID

		_filterList17 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList17 != nil {
			list = _filterList17.conditions
			for _, _item := range _f.mem.lookupList(_filterList17.conditions) {
				subquery = _item
				_subquery8 := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery8 != nil {
					subqueryInput = _subquery8.input
					projection = _subquery8.projection
					_f.maxSteps--
					_group = _f.ConstructInnerJoinApply(_f.ConstructInnerJoinApply(left, right, _f.ConstructTrue()), subqueryInput, _f.ConstructFilterList(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [EnsureJoinFilterList]
	{
		_filterList18 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList18 == nil {
			if _f.useFilterList(filter) {
				_f.maxSteps--
				_group = _f.ConstructInnerJoinApply(left, right, _f.flattenFilterCondition(filter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [MergeJoinSelect]
	{
		var input GroupID
		var selectFilter GroupID

		_select7 := _f.mem.lookupNormExpr(right).asSelect()
		if _select7 != nil {
			input = _select7.input
			selectFilter = _select7.filter
			if _f.hasUnboundCols(right) {
				_f.maxSteps--
				_group = _f.ConstructInnerJoinApply(left, input, _f.concatFilterConditions(filter, selectFilter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeInnerJoinApply(&_innerJoinApplyExpr))
}

func (_f *Factory) ConstructLeftJoinApply(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_leftJoinApplyExpr := leftJoinApplyExpr{memoExpr: memoExpr{op: LeftJoinApplyOp}, left: left, right: right, filter: filter}
	_fingerprint := _leftJoinApplyExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeLeftJoinApply(&_leftJoinApplyExpr)
	}

	// [HoistJoinProject]
	{
		var input GroupID
		var projections GroupID

		_project2 := _f.mem.lookupNormExpr(right).asProject()
		if _project2 != nil {
			input = _project2.input
			projections = _project2.projections
			if _f.isCorrelated(right, left) {
				_f.maxSteps--
				_group = _f.ConstructSelect(_f.ConstructProject(_f.ConstructLeftJoinApply(left, input, _f.ConstructTrue()), _f.appendColumnProjections(projections, left)), filter)
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [HoistJoinGroupBy]
	{
		var input GroupID
		var items ListID
		var aggregations GroupID

		_groupBy2 := _f.mem.lookupNormExpr(right).asGroupBy()
		if _groupBy2 != nil {
			input = _groupBy2.input
			_projections2 := _f.mem.lookupNormExpr(_groupBy2.groupings).asProjections()
			if _projections2 != nil {
				items = _projections2.items
				if _f.isEmptyList(items) {
					aggregations = _groupBy2.aggregations
					if _f.isCorrelated(right, left) {
						_f.maxSteps--
						_group = _f.ConstructSelect(_f.ConstructGroupBy(_f.ConstructLeftJoinApply(left, input, _f.ConstructTrue()), _f.columnProjections(left), aggregations), filter)
						_f.mem.addAltFingerprint(_fingerprint, _group)
						return _group
					}
				}
			}
		}
	}

	// [DecorrelateJoin]
	{
		if !_f.isCorrelated(right, left) {
			_f.maxSteps--
			_group = _f.nonJoinApply(LeftJoinApplyOp, left, right, filter)
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	// [HoistJoinFilterSubquery]
	{
		var list ListID
		var subquery GroupID
		var subqueryInput GroupID
		var projection GroupID

		_filterList19 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList19 != nil {
			list = _filterList19.conditions
			for _, _item := range _f.mem.lookupList(_filterList19.conditions) {
				subquery = _item
				_subquery9 := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery9 != nil {
					subqueryInput = _subquery9.input
					projection = _subquery9.projection
					_f.maxSteps--
					_group = _f.ConstructInnerJoinApply(_f.ConstructLeftJoinApply(left, right, _f.ConstructTrue()), subqueryInput, _f.ConstructFilterList(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [EnsureJoinFilterList]
	{
		_filterList20 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList20 == nil {
			if _f.useFilterList(filter) {
				_f.maxSteps--
				_group = _f.ConstructLeftJoinApply(left, right, _f.flattenFilterCondition(filter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [MergeJoinSelect]
	{
		var input GroupID
		var selectFilter GroupID

		_select8 := _f.mem.lookupNormExpr(right).asSelect()
		if _select8 != nil {
			input = _select8.input
			selectFilter = _select8.filter
			if _f.hasUnboundCols(right) {
				_f.maxSteps--
				_group = _f.ConstructLeftJoinApply(left, input, _f.concatFilterConditions(filter, selectFilter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeLeftJoinApply(&_leftJoinApplyExpr))
}

func (_f *Factory) ConstructRightJoinApply(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_rightJoinApplyExpr := rightJoinApplyExpr{memoExpr: memoExpr{op: RightJoinApplyOp}, left: left, right: right, filter: filter}
	_fingerprint := _rightJoinApplyExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeRightJoinApply(&_rightJoinApplyExpr)
	}

	// [HoistJoinProject]
	{
		var input GroupID
		var projections GroupID

		_project3 := _f.mem.lookupNormExpr(right).asProject()
		if _project3 != nil {
			input = _project3.input
			projections = _project3.projections
			if _f.isCorrelated(right, left) {
				_f.maxSteps--
				_group = _f.ConstructSelect(_f.ConstructProject(_f.ConstructRightJoinApply(left, input, _f.ConstructTrue()), _f.appendColumnProjections(projections, left)), filter)
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [HoistJoinGroupBy]
	{
		var input GroupID
		var items ListID
		var aggregations GroupID

		_groupBy3 := _f.mem.lookupNormExpr(right).asGroupBy()
		if _groupBy3 != nil {
			input = _groupBy3.input
			_projections3 := _f.mem.lookupNormExpr(_groupBy3.groupings).asProjections()
			if _projections3 != nil {
				items = _projections3.items
				if _f.isEmptyList(items) {
					aggregations = _groupBy3.aggregations
					if _f.isCorrelated(right, left) {
						_f.maxSteps--
						_group = _f.ConstructSelect(_f.ConstructGroupBy(_f.ConstructLeftJoinApply(left, input, _f.ConstructTrue()), _f.columnProjections(left), aggregations), filter)
						_f.mem.addAltFingerprint(_fingerprint, _group)
						return _group
					}
				}
			}
		}
	}

	// [DecorrelateJoin]
	{
		if !_f.isCorrelated(right, left) {
			_f.maxSteps--
			_group = _f.nonJoinApply(RightJoinApplyOp, left, right, filter)
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	// [HoistJoinFilterSubquery]
	{
		var list ListID
		var subquery GroupID
		var subqueryInput GroupID
		var projection GroupID

		_filterList21 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList21 != nil {
			list = _filterList21.conditions
			for _, _item := range _f.mem.lookupList(_filterList21.conditions) {
				subquery = _item
				_subquery10 := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery10 != nil {
					subqueryInput = _subquery10.input
					projection = _subquery10.projection
					_f.maxSteps--
					_group = _f.ConstructInnerJoinApply(_f.ConstructRightJoinApply(left, right, _f.ConstructTrue()), subqueryInput, _f.ConstructFilterList(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [EnsureJoinFilterList]
	{
		_filterList22 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList22 == nil {
			if _f.useFilterList(filter) {
				_f.maxSteps--
				_group = _f.ConstructRightJoinApply(left, right, _f.flattenFilterCondition(filter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [MergeJoinSelect]
	{
		var input GroupID
		var selectFilter GroupID

		_select9 := _f.mem.lookupNormExpr(right).asSelect()
		if _select9 != nil {
			input = _select9.input
			selectFilter = _select9.filter
			if _f.hasUnboundCols(right) {
				_f.maxSteps--
				_group = _f.ConstructRightJoinApply(left, input, _f.concatFilterConditions(filter, selectFilter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeRightJoinApply(&_rightJoinApplyExpr))
}

func (_f *Factory) ConstructFullJoinApply(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_fullJoinApplyExpr := fullJoinApplyExpr{memoExpr: memoExpr{op: FullJoinApplyOp}, left: left, right: right, filter: filter}
	_fingerprint := _fullJoinApplyExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeFullJoinApply(&_fullJoinApplyExpr)
	}

	// [HoistJoinProject]
	{
		var input GroupID
		var projections GroupID

		_project4 := _f.mem.lookupNormExpr(right).asProject()
		if _project4 != nil {
			input = _project4.input
			projections = _project4.projections
			if _f.isCorrelated(right, left) {
				_f.maxSteps--
				_group = _f.ConstructSelect(_f.ConstructProject(_f.ConstructFullJoinApply(left, input, _f.ConstructTrue()), _f.appendColumnProjections(projections, left)), filter)
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [HoistJoinGroupBy]
	{
		var input GroupID
		var items ListID
		var aggregations GroupID

		_groupBy4 := _f.mem.lookupNormExpr(right).asGroupBy()
		if _groupBy4 != nil {
			input = _groupBy4.input
			_projections4 := _f.mem.lookupNormExpr(_groupBy4.groupings).asProjections()
			if _projections4 != nil {
				items = _projections4.items
				if _f.isEmptyList(items) {
					aggregations = _groupBy4.aggregations
					if _f.isCorrelated(right, left) {
						_f.maxSteps--
						_group = _f.ConstructSelect(_f.ConstructGroupBy(_f.ConstructLeftJoinApply(left, input, _f.ConstructTrue()), _f.columnProjections(left), aggregations), filter)
						_f.mem.addAltFingerprint(_fingerprint, _group)
						return _group
					}
				}
			}
		}
	}

	// [DecorrelateJoin]
	{
		if !_f.isCorrelated(right, left) {
			_f.maxSteps--
			_group = _f.nonJoinApply(FullJoinApplyOp, left, right, filter)
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	// [HoistJoinFilterSubquery]
	{
		var list ListID
		var subquery GroupID
		var subqueryInput GroupID
		var projection GroupID

		_filterList23 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList23 != nil {
			list = _filterList23.conditions
			for _, _item := range _f.mem.lookupList(_filterList23.conditions) {
				subquery = _item
				_subquery11 := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery11 != nil {
					subqueryInput = _subquery11.input
					projection = _subquery11.projection
					_f.maxSteps--
					_group = _f.ConstructInnerJoinApply(_f.ConstructFullJoinApply(left, right, _f.ConstructTrue()), subqueryInput, _f.ConstructFilterList(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [EnsureJoinFilterList]
	{
		_filterList24 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList24 == nil {
			if _f.useFilterList(filter) {
				_f.maxSteps--
				_group = _f.ConstructFullJoinApply(left, right, _f.flattenFilterCondition(filter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [MergeJoinSelect]
	{
		var input GroupID
		var selectFilter GroupID

		_select10 := _f.mem.lookupNormExpr(right).asSelect()
		if _select10 != nil {
			input = _select10.input
			selectFilter = _select10.filter
			if _f.hasUnboundCols(right) {
				_f.maxSteps--
				_group = _f.ConstructFullJoinApply(left, input, _f.concatFilterConditions(filter, selectFilter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeFullJoinApply(&_fullJoinApplyExpr))
}

func (_f *Factory) ConstructSemiJoinApply(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_semiJoinApplyExpr := semiJoinApplyExpr{memoExpr: memoExpr{op: SemiJoinApplyOp}, left: left, right: right, filter: filter}
	_fingerprint := _semiJoinApplyExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeSemiJoinApply(&_semiJoinApplyExpr)
	}

	// [HoistJoinProject]
	{
		var input GroupID
		var projections GroupID

		_project5 := _f.mem.lookupNormExpr(right).asProject()
		if _project5 != nil {
			input = _project5.input
			projections = _project5.projections
			if _f.isCorrelated(right, left) {
				_f.maxSteps--
				_group = _f.ConstructSelect(_f.ConstructProject(_f.ConstructSemiJoinApply(left, input, _f.ConstructTrue()), _f.appendColumnProjections(projections, left)), filter)
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [HoistJoinGroupBy]
	{
		var input GroupID
		var items ListID
		var aggregations GroupID

		_groupBy5 := _f.mem.lookupNormExpr(right).asGroupBy()
		if _groupBy5 != nil {
			input = _groupBy5.input
			_projections5 := _f.mem.lookupNormExpr(_groupBy5.groupings).asProjections()
			if _projections5 != nil {
				items = _projections5.items
				if _f.isEmptyList(items) {
					aggregations = _groupBy5.aggregations
					if _f.isCorrelated(right, left) {
						_f.maxSteps--
						_group = _f.ConstructSelect(_f.ConstructGroupBy(_f.ConstructLeftJoinApply(left, input, _f.ConstructTrue()), _f.columnProjections(left), aggregations), filter)
						_f.mem.addAltFingerprint(_fingerprint, _group)
						return _group
					}
				}
			}
		}
	}

	// [DecorrelateJoin]
	{
		if !_f.isCorrelated(right, left) {
			_f.maxSteps--
			_group = _f.nonJoinApply(SemiJoinApplyOp, left, right, filter)
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	// [HoistJoinFilterSubquery]
	{
		var list ListID
		var subquery GroupID
		var subqueryInput GroupID
		var projection GroupID

		_filterList25 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList25 != nil {
			list = _filterList25.conditions
			for _, _item := range _f.mem.lookupList(_filterList25.conditions) {
				subquery = _item
				_subquery12 := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery12 != nil {
					subqueryInput = _subquery12.input
					projection = _subquery12.projection
					_f.maxSteps--
					_group = _f.ConstructInnerJoinApply(_f.ConstructSemiJoinApply(left, right, _f.ConstructTrue()), subqueryInput, _f.ConstructFilterList(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [EnsureJoinFilterList]
	{
		_filterList26 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList26 == nil {
			if _f.useFilterList(filter) {
				_f.maxSteps--
				_group = _f.ConstructSemiJoinApply(left, right, _f.flattenFilterCondition(filter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [MergeJoinSelect]
	{
		var input GroupID
		var selectFilter GroupID

		_select11 := _f.mem.lookupNormExpr(right).asSelect()
		if _select11 != nil {
			input = _select11.input
			selectFilter = _select11.filter
			if _f.hasUnboundCols(right) {
				_f.maxSteps--
				_group = _f.ConstructSemiJoinApply(left, input, _f.concatFilterConditions(filter, selectFilter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeSemiJoinApply(&_semiJoinApplyExpr))
}

func (_f *Factory) ConstructAntiJoinApply(
	left GroupID,
	right GroupID,
	filter GroupID,
) GroupID {
	_antiJoinApplyExpr := antiJoinApplyExpr{memoExpr: memoExpr{op: AntiJoinApplyOp}, left: left, right: right, filter: filter}
	_fingerprint := _antiJoinApplyExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	if _f.maxSteps <= 0 {
		return _f.mem.memoizeAntiJoinApply(&_antiJoinApplyExpr)
	}

	// [HoistJoinProject]
	{
		var input GroupID
		var projections GroupID

		_project6 := _f.mem.lookupNormExpr(right).asProject()
		if _project6 != nil {
			input = _project6.input
			projections = _project6.projections
			if _f.isCorrelated(right, left) {
				_f.maxSteps--
				_group = _f.ConstructSelect(_f.ConstructProject(_f.ConstructAntiJoinApply(left, input, _f.ConstructTrue()), _f.appendColumnProjections(projections, left)), filter)
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [HoistJoinGroupBy]
	{
		var input GroupID
		var items ListID
		var aggregations GroupID

		_groupBy6 := _f.mem.lookupNormExpr(right).asGroupBy()
		if _groupBy6 != nil {
			input = _groupBy6.input
			_projections6 := _f.mem.lookupNormExpr(_groupBy6.groupings).asProjections()
			if _projections6 != nil {
				items = _projections6.items
				if _f.isEmptyList(items) {
					aggregations = _groupBy6.aggregations
					if _f.isCorrelated(right, left) {
						_f.maxSteps--
						_group = _f.ConstructSelect(_f.ConstructGroupBy(_f.ConstructLeftJoinApply(left, input, _f.ConstructTrue()), _f.columnProjections(left), aggregations), filter)
						_f.mem.addAltFingerprint(_fingerprint, _group)
						return _group
					}
				}
			}
		}
	}

	// [DecorrelateJoin]
	{
		if !_f.isCorrelated(right, left) {
			_f.maxSteps--
			_group = _f.nonJoinApply(AntiJoinApplyOp, left, right, filter)
			_f.mem.addAltFingerprint(_fingerprint, _group)
			return _group
		}
	}

	// [HoistJoinFilterSubquery]
	{
		var list ListID
		var subquery GroupID
		var subqueryInput GroupID
		var projection GroupID

		_filterList27 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList27 != nil {
			list = _filterList27.conditions
			for _, _item := range _f.mem.lookupList(_filterList27.conditions) {
				subquery = _item
				_subquery13 := _f.mem.lookupNormExpr(_item).asSubquery()
				if _subquery13 != nil {
					subqueryInput = _subquery13.input
					projection = _subquery13.projection
					_f.maxSteps--
					_group = _f.ConstructInnerJoinApply(_f.ConstructAntiJoinApply(left, right, _f.ConstructTrue()), subqueryInput, _f.ConstructFilterList(_f.replaceListItem(list, subquery, projection)))
					_f.mem.addAltFingerprint(_fingerprint, _group)
					return _group
				}
			}
		}
	}

	// [EnsureJoinFilterList]
	{
		_filterList28 := _f.mem.lookupNormExpr(filter).asFilterList()
		if _filterList28 == nil {
			if _f.useFilterList(filter) {
				_f.maxSteps--
				_group = _f.ConstructAntiJoinApply(left, right, _f.flattenFilterCondition(filter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	// [MergeJoinSelect]
	{
		var input GroupID
		var selectFilter GroupID

		_select12 := _f.mem.lookupNormExpr(right).asSelect()
		if _select12 != nil {
			input = _select12.input
			selectFilter = _select12.filter
			if _f.hasUnboundCols(right) {
				_f.maxSteps--
				_group = _f.ConstructAntiJoinApply(left, input, _f.concatFilterConditions(filter, selectFilter))
				_f.mem.addAltFingerprint(_fingerprint, _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeAntiJoinApply(&_antiJoinApplyExpr))
}

func (_f *Factory) ConstructGroupBy(
	input GroupID,
	groupings GroupID,
	aggregations GroupID,
) GroupID {
	_groupByExpr := groupByExpr{memoExpr: memoExpr{op: GroupByOp}, input: input, groupings: groupings, aggregations: aggregations}
	_fingerprint := _groupByExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeGroupBy(&_groupByExpr))
}

func (_f *Factory) ConstructUnion(
	left GroupID,
	right GroupID,
	colMap PrivateID,
) GroupID {
	_unionExpr := unionExpr{memoExpr: memoExpr{op: UnionOp}, left: left, right: right, colMap: colMap}
	_fingerprint := _unionExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeUnion(&_unionExpr))
}

func (_f *Factory) ConstructIntersect(
	left GroupID,
	right GroupID,
) GroupID {
	_intersectExpr := intersectExpr{memoExpr: memoExpr{op: IntersectOp}, left: left, right: right}
	_fingerprint := _intersectExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeIntersect(&_intersectExpr))
}

func (_f *Factory) ConstructExcept(
	left GroupID,
	right GroupID,
) GroupID {
	_exceptExpr := exceptExpr{memoExpr: memoExpr{op: ExceptOp}, left: left, right: right}
	_fingerprint := _exceptExpr.fingerprint()
	_group := _f.mem.lookupGroupByFingerprint(_fingerprint)
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeExcept(&_exceptExpr))
}

type dynConstructLookupFunc func(f *Factory, children []GroupID, private PrivateID) GroupID

var dynConstructLookup = []dynConstructLookupFunc{
	// UnknownOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		panic("op type not initialized")
	},

	// SubqueryOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructSubquery(children[0], children[1])
	},

	// VariableOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructVariable(private)
	},

	// ConstOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructConst(private)
	},

	// PlaceholderOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructPlaceholder(private)
	},

	// ListOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructList(f.StoreList(children))
	},

	// OrderedListOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructOrderedList(f.StoreList(children))
	},

	// FilterListOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructFilterList(f.StoreList(children))
	},

	// ProjectionsOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructProjections(f.StoreList(children), private)
	},

	// ExistsOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructExists(children[0])
	},

	// AndOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructAnd(children[0], children[1])
	},

	// OrOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructOr(children[0], children[1])
	},

	// NotOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructNot(children[0])
	},

	// EqOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructEq(children[0], children[1])
	},

	// LtOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructLt(children[0], children[1])
	},

	// GtOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructGt(children[0], children[1])
	},

	// LeOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructLe(children[0], children[1])
	},

	// GeOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructGe(children[0], children[1])
	},

	// NeOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructNe(children[0], children[1])
	},

	// InOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructIn(children[0], children[1])
	},

	// NotInOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructNotIn(children[0], children[1])
	},

	// LikeOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructLike(children[0], children[1])
	},

	// NotLikeOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructNotLike(children[0], children[1])
	},

	// ILikeOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructILike(children[0], children[1])
	},

	// NotILikeOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructNotILike(children[0], children[1])
	},

	// SimilarToOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructSimilarTo(children[0], children[1])
	},

	// NotSimilarToOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructNotSimilarTo(children[0], children[1])
	},

	// RegMatchOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructRegMatch(children[0], children[1])
	},

	// NotRegMatchOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructNotRegMatch(children[0], children[1])
	},

	// RegIMatchOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructRegIMatch(children[0], children[1])
	},

	// NotRegIMatchOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructNotRegIMatch(children[0], children[1])
	},

	// IsDistinctFromOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructIsDistinctFrom(children[0], children[1])
	},

	// IsNotDistinctFromOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructIsNotDistinctFrom(children[0], children[1])
	},

	// IsOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructIs(children[0], children[1])
	},

	// IsNotOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructIsNot(children[0], children[1])
	},

	// AnyOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructAny(children[0], children[1])
	},

	// SomeOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructSome(children[0], children[1])
	},

	// AllOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructAll(children[0], children[1])
	},

	// BitandOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructBitand(children[0], children[1])
	},

	// BitorOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructBitor(children[0], children[1])
	},

	// BitxorOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructBitxor(children[0], children[1])
	},

	// PlusOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructPlus(children[0], children[1])
	},

	// MinusOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructMinus(children[0], children[1])
	},

	// MultOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructMult(children[0], children[1])
	},

	// DivOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructDiv(children[0], children[1])
	},

	// FloorDivOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructFloorDiv(children[0], children[1])
	},

	// ModOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructMod(children[0], children[1])
	},

	// PowOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructPow(children[0], children[1])
	},

	// ConcatOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructConcat(children[0], children[1])
	},

	// LShiftOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructLShift(children[0], children[1])
	},

	// RShiftOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructRShift(children[0], children[1])
	},

	// UnaryPlusOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructUnaryPlus(children[0])
	},

	// UnaryMinusOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructUnaryMinus(children[0])
	},

	// UnaryComplementOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructUnaryComplement(children[0])
	},

	// FunctionOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructFunction(f.StoreList(children), private)
	},

	// TrueOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructTrue()
	},

	// FalseOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructFalse()
	},

	// ScanOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructScan(private)
	},

	// ValuesOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructValues()
	},

	// SelectOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructSelect(children[0], children[1])
	},

	// ProjectOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructProject(children[0], children[1])
	},

	// InnerJoinOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructInnerJoin(children[0], children[1], children[2])
	},

	// LeftJoinOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructLeftJoin(children[0], children[1], children[2])
	},

	// RightJoinOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructRightJoin(children[0], children[1], children[2])
	},

	// FullJoinOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructFullJoin(children[0], children[1], children[2])
	},

	// SemiJoinOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructSemiJoin(children[0], children[1], children[2])
	},

	// AntiJoinOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructAntiJoin(children[0], children[1], children[2])
	},

	// InnerJoinApplyOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructInnerJoinApply(children[0], children[1], children[2])
	},

	// LeftJoinApplyOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructLeftJoinApply(children[0], children[1], children[2])
	},

	// RightJoinApplyOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructRightJoinApply(children[0], children[1], children[2])
	},

	// FullJoinApplyOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructFullJoinApply(children[0], children[1], children[2])
	},

	// SemiJoinApplyOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructSemiJoinApply(children[0], children[1], children[2])
	},

	// AntiJoinApplyOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructAntiJoinApply(children[0], children[1], children[2])
	},

	// GroupByOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructGroupBy(children[0], children[1], children[2])
	},

	// UnionOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructUnion(children[0], children[1], private)
	},

	// IntersectOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructIntersect(children[0], children[1])
	},

	// ExceptOp
	func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructExcept(children[0], children[1])
	},
}

func (f *Factory) dynamicConstruct(op Operator, children []GroupID, private PrivateID) GroupID {
	return dynConstructLookup[op](f, children, private)
}
